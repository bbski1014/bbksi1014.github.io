<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>线代Note</title>
    <link href="/2022/04/18/%E7%BA%BF%E4%BB%A3Note/"/>
    <url>/2022/04/18/%E7%BA%BF%E4%BB%A3Note/</url>
    
    <content type="html"><![CDATA[<h1 id="线代note">线代NOTE</h1><p>相关网站 <a href="https://ccjou.wordpress.com/">线代启示</a></p><p>需要补充的</p><p>Laplace展开定理</p><p>分块矩阵的行列式计算</p><p>行列式章节</p><h1 id="行列式">行列式</h1><h2 id="定义">定义</h2><p>由n^2个元素a_ij(i,j=1……n)排成一个n行n列的正方形数表： <span class="math display">\[\left|    \begin{matrix}    a_{11}&amp;a_{12}&amp;a_{13}&amp;\cdots&amp;a_{1n}\\    a_{21}&amp;a_{22}&amp;a_{23}&amp;\cdots&amp;a_{2n}\\    \vdots&amp;\vdots&amp;\vdots&amp;\ddots&amp;a_{3n}\\    a_{n1}&amp;a_{n2}&amp;a_{n3}&amp;\cdots&amp;a_{nn}    \end{matrix}\right|\]</span> 由这个数表所决定的数， <span class="math display">\[\sum_{p_1p_2p_3\cdots{p_n}}(-1)^{t^{(p_1p_2p_3\cdots{p_n})}}a_{1p_1}a_{2p_2}a_{3p_3}\cdots{a_{np_n}}(第一定义)\]</span> 称为这个n x n 数表构成的n阶行列式，记为 <span class="math display">\[D_n=\left|    \begin{matrix}    a_{11}&amp;a_{12}&amp;a_{13}&amp;\cdots&amp;a_{1n}\\    a_{21}&amp;a_{22}&amp;a_{23}&amp;\cdots&amp;a_{2n}\\    \vdots&amp;\vdots&amp;\vdots&amp;\ddots&amp;a_{3n}\\    a_{n1}&amp;a_{n2}&amp;a_{n3}&amp;\cdots&amp;a_{nn}    \end{matrix}\right|=\sum_{p_1p_2p_3\cdots{p_n}}(-1)^{t^{(p_1p_2p_3\cdots{p_n})}}a_{1p_1}a_{2p_2}a_{3p_3}\cdots{a_{np_n}}\\t^{(p_1p_2p_3\cdots{p_n})}为n阶全排列{p_1p_2p_3\cdots{p_n}}的逆序数\]</span> 若有方阵A，简记其行列式|A|，或|A|=det(a_ij)_、|a_ij|_nxn、|a_ij|_n</p><p>特别的，|a_11|=a_11</p><p>上述是行列式按列标全排列的所有可能(按行展开,行标是自然排列)来定义的，按行标(按列展开，列标不是自然排列)亦可 <span class="math display">\[\sum_{p_1p_2p_3\cdots{p_n}}(-1)^{t^{(p_1p_2p_3\cdots{p_n})}}a_{p_1{1}}a_{p_2{2}}a_{p_3{3}}\cdots{a_{p_nn}}(第二定义)\]</span> *<strong>也可以，不按行不按列展开(行标，列标都不是标准排列），这样某一项的<u>正负是有行标和列标各自的全排列的逆序数之和决定</u></strong>(第三定义)</p><h2 id="排列和逆序数">排列和逆序数</h2><p>定义1：从1,2,3，……,n中任意选取r个不同的书排成一列，称为排列</p><p>定义2：将1,2,3，……,n这n个不同的数排成一列，成为n阶全排列，简称全排列，数量为n！</p><p>定义3：如果一个排列中，存在排在左边的数必排在其右边的数大，即破坏了排列的自然顺序，则称他们为一个逆序；</p><p>​ <strong>一个排列中逆序的总数称为这个排列的逆序数</strong></p><p>定义4：逆序数为偶数的排列称为偶排列；逆序数称为奇数的排列称为奇排列。</p><p>定理1：元素对换改变排列奇偶性</p><p>定理2：在n阶全排列中，偶排列和奇排列各占一半，即各有n!/2</p><h2 id="性质">性质</h2><p>性质1：D^T=D(第一和第二定义)</p><p>性质2：两行对换，D‘=-D(第三定义)</p><p>性质3：两行相等，D=0 （2的推论-D=D,即D+D=0）</p><p>性质4：某一行有公因子k，可朝外提取1次；全部行有公因子k，可向外提取n次，即k^n</p><p>性质5：存在两行对应成比例，D=0</p><p>性质6：某一行全为0，则D=0</p><p>注意：D=0并不意味着性质3，5，6存在一个</p><p>如，下述行列式为0 <span class="math display">\[\left|\begin{matrix}    1 &amp; 2 &amp; 3\\   4 &amp; 5 &amp; 6\\   7 &amp; 8 &amp; 9\end{matrix}\right|\]</span> 性质7：行列式中，是行的那一行分开，<strong>其余行保持不变</strong>(容易错误) <span class="math display">\[\left|\begin{matrix}    b+c &amp; c+a &amp; a+b\\   a+b &amp; b+c &amp; c+a\\   c+a &amp; a+b &amp; b+c\end{matrix}\right|=\left|\begin{matrix}    b &amp; c &amp; a\\   a+b &amp; b+c &amp; c+a\\   c+a &amp; a+b &amp; b+c\end{matrix}\right|+\left|\begin{matrix}    c &amp; a &amp; b\\   a+b &amp; b+c &amp; c+a\\   c+a &amp; a+b &amp; b+c\end{matrix}\right|\\(一共可展开8项)\]</span> *性质8：某一行乘以一个数加到另一行，行列式的值不变(不能说减去)</p><p><strong>根据行列式，行与列地位同等的定理，上述性质， 对行也成立。</strong></p><h2 id="行列式的展开">行列式的展开</h2><h3 id="代数余子式和余子式">代数余子式和余子式</h3><p><span class="math display">\[A_{ij}=(-1)^{(i+j)}M_{ij}\]</span></p><p>设有行列式|A|，则 <span class="math display">\[|A|=a_{i1}A_{i1}+a_{i2}A_{i2}+\cdots+a_{in}A_{in}\]</span> 和 <span class="math display">\[|A|=a_{1j}A_{1j}+a_{2j}A_{2j}+\cdots+a_{nj}A_{nj}\]</span> 则称上述两式分别为<strong>|A|按第i行展开的展开式和按第j列展开的展开式</strong></p><p><strong>异乘变零定理：</strong>某一行元素与另一行元素的代数余子式的乘积之和为0(与伴随矩阵有关,证明从两行相等，行列式为0的角度思考)</p><p>(对列也成立)</p><h3 id="拉普拉斯展开定理">拉普拉斯展开定理</h3><p>取定行列式k行，有k行元素组成的所有k阶子式与与代数余子式乘积之和为D，正负由取定的k行 和 k列的下标之和决定</p><h2 id="行列式和特殊行列式的计算">行列式和特殊行列式的计算</h2><p>同阶行列式相乘：可按矩阵相乘运算来算</p><p>不同阶或者同阶，行列式相乘的结果就是两行列式的数值相乘。</p><p>熟悉2阶和3阶行列式的计算</p><p>上三角方阵和下三角方阵的行列式皆为，主对角线元素的乘积</p><p>反上三角和下三角方阵的行列式为，次对角元素相乘，正负有对角线列标之和决定</p><p>三叉形行列式</p><p>范德蒙德行列式的计算公式要掌握</p><p>反对称行列式，奇数阶，D=0</p><h2 id="克莱姆法则">克莱姆法则</h2><h1 id="矩阵">矩阵</h1><h2 id="矩阵定义">1、矩阵定义</h2><h3 id="线性方程组">1、线性方程组</h3><p>对于一个由m个方程和n个未知量的线性方程组： <span class="math display">\[\begin{cases}                                    a_{11}x_{1}+a_{12}x_{2}+\cdots+a_{1n}x_{n}=b_{1}\\    a_{11}x_{1}+a_{12}x_{2}+\cdots+a_{1n}x_{n}=b_{2}\\    \cdots\cdots\cdots\\    a_{m1}x_{1}+a_{m2}x_{2}+\cdots+a_{mn}x_{n}=b_{m}\end{cases}\]</span></p><p>在这个线性方程组中，重要信息是<strong>未知量的个数</strong> 以及 <strong>未知量系数</strong>和<strong>常数项</strong>,由此可以组成一个m x (n+1)规格的有序数表，用来反映出对应的线性方程组的所有信息。 <span class="math display">\[\widetilde{A}=\left(    \begin{matrix}    a_{11}&amp;a_{12}&amp;a_{13}&amp;\cdots&amp;a_{1n}&amp;b_{1}\\    a_{11}&amp;a_{12}&amp;a_{13}&amp;\cdots&amp;a_{2n}&amp;b_{1}\\    \vdots&amp;\vdots&amp;\vdots&amp;\ddots&amp;a_{3n}&amp;\vdots\\    a_{11}&amp;a_{12}&amp;a_{13}&amp;\cdots&amp;a_{mn}&amp;b_{1}    \end{matrix}\right)\]</span> 将这样的一个数表称为一个m x n矩阵，可以简记为（a_ij),或者（a_ij)_m x n</p><h3 id="特殊矩阵">2、特殊矩阵</h3><p><span class="math display">\[\begin{align}&amp;1\times1{矩阵}A=(a){，记A=a}\\&amp;1\times{n}{矩阵}A=(a_{1},a_{2},\cdots,a_{n}){,称行矩阵，亦称n维行向量}\\&amp;m\times1{矩阵}A=\left(    \begin{matrix}        a_{1}\\        a_{2}\\        \vdots        a_{m}    \end{matrix}\right)称为列矩阵，亦称m维列向量\\&amp;{所有元素都是0的矩阵称为零矩阵，记O}\\\end{align}\\\]</span></p><h3 id="n阶方阵">3、n阶方阵</h3><p>主对角线的概念只存在于方阵中 <span class="math display">\[\begin{align}&amp;{n}\times{n}{矩阵称为n阶方针}\\&amp;A=\left(    \begin{matrix}        a_{11}&amp;a_{12}&amp;\cdots&amp;a_{1n}\\        a_{21}&amp;a_{22}&amp;\cdots&amp;a_{2n}\\        \vdots&amp;\vdots&amp;\ddots&amp;\vdots\\        a_{n1}&amp;a_{n2}&amp;\cdots&amp;a_{nn}    \end{matrix}\right)\\\\&amp;{对角矩阵:a_{ij}=0,当i&gt;j时}\\&amp;A=\left(    \begin{matrix}        a_{11}&amp;0&amp;\cdots&amp;0\\        0&amp;a_{22}&amp;\cdots&amp;0\\        \vdots&amp;\vdots&amp;\ddots&amp;\vdots\\        0&amp;0&amp;\cdots&amp;a_{nn}    \end{matrix}\right)\\&amp;{称为n阶对角矩阵，记diag(a_{11},a_{22},\cdots,a_{nn})}\\\\&amp;当a_{11}=a_{22}=\cdots=a_{nn}，称数量矩阵\\&amp;A=\left(    \begin{matrix}        a&amp;0&amp;\cdots&amp;0\\        0&amp;a&amp;\cdots&amp;0\\        \vdots&amp;\vdots&amp;\ddots&amp;\vdots\\        0&amp;0&amp;\cdots&amp;a    \end{matrix}\right)\\\\&amp;当a_{ii}=1，就称这个矩阵为n阶单位矩阵，记为E_n或E\\&amp;A=3\\&amp;{最后注意，}A=aE\\\end{align}\]</span> <strong>（一般空的地方表示元素是0）</strong></p><h4 id="关于对角矩阵的性质">关于对角矩阵的性质：</h4>$$ (<span class="math display">\[\begin{matrix}        1&amp;2&amp;3\\        2&amp;2&amp;3\\        1&amp;3&amp;4    \end{matrix}\]</span><p>)</p>(<span class="math display">\[\begin{matrix}        k_{1}&amp;0&amp;0\\        0&amp;k_{2}&amp;0\\        0&amp;0&amp;k_{3}    \end{matrix}\]</span><h1 id="section">)</h1>(<span class="math display">\[\begin{matrix}        1_1&amp;2k_1&amp;3k_1\\        2k_2&amp;2k_2&amp;3k_2\\        1k_3&amp;3k_3&amp;4k_3    \end{matrix}\]</span><p>)</p>\ (<span class="math display">\[\begin{matrix}        a_{1}&amp;0&amp;0\\        0&amp;a_{2}&amp;0\\        0&amp;0&amp;a_{3}    \end{matrix}\]</span><p>)</p>(<span class="math display">\[\begin{matrix}        k_{1}&amp;0&amp;0\\        0&amp;k_{2}&amp;0\\        0&amp;0&amp;k_{3}    \end{matrix}\]</span><h1 id="section-1">)</h1>(<span class="math display">\[\begin{matrix}        1k_1&amp;2k_3&amp;3k_3\\        2k_1&amp;2k_2&amp;3k_3\\        1k_1&amp;3k_3&amp;4k_3    \end{matrix}\]</span><p>) $$</p><p><strong>左行右列</strong></p><h4 id="对称矩阵和反对称矩阵属于方阵">对称矩阵和反对称矩阵(属于方阵)</h4><p><span class="math display">\[\begin{align}&amp;对称矩阵满足a_{ij}=a_{ji},满足A^T=A\\&amp;反对称矩阵满足a_{ij}=a_{ji},满足A^T=-A\end{align}\]</span></p><h3 id="矩阵的相等">4、矩阵的相等</h3><p>两个矩阵行数，列数分别相等，则称两个矩阵为同形矩阵；</p><p>（相等前提）</p><p>如果两个同形矩阵对应元素都相等，则A=B,两矩阵相等。</p><p>注意：两个零矩阵之间的规格可能不等，也就是两个零矩阵不一定相等</p><h2 id="矩阵线性运算与运算律">2、矩阵线性运算与运算律</h2><h4 id="矩阵加法">矩阵加法</h4><p>设A，B是同形矩阵，则A+B为对应元素相加之后的得到的矩阵</p><p><strong>加法运算律：</strong></p><ul><li>交换律:A+B=B+A</li><li>结合律:(A+B)+C=A+(B+C)</li><li>A+O=O+A=A</li></ul><h4 id="矩阵数乘">矩阵数乘</h4><p>kA=aK=(ka_ij)_m x n</p><p>k(A+B)=kA+kB</p><p>(kl)A=k(lA)=l(kA)</p><p>0A_m xn=O_mxn</p><p>(矩阵提公因子：矩阵所有元素有公因子k,公因子向外提取一次，与行列式不同)</p><h4 id="矩阵乘法">矩阵乘法</h4><p><strong>设有两个矩阵A_mxp与B_qxn，两矩阵可相乘的前提条件是，p=q;</strong></p><p>(相等可乘，不等不乘)</p><p>得出的矩阵的规格为m x n;</p><p>(中间相等取两头m p q n) <span class="math display">\[c_{ij}=\sum^{p}_{k=1}a_{i1}b_{1j}+a_{i2}b_{2j}+\cdots+a_{ip}b_{pj}\]</span></p><h4 id="矩阵乘法运算律">矩阵乘法运算律</h4><ul><li>结合律(AB)C=A(BC)</li><li>分配律A(B+C)=AB+AC,(A+B)C=AC+BC</li><li>(kA)B=A(kB)=k(AB)</li><li><strong>E_m A_mxn = A_mxn E_n = A_mxn（很重要）</strong></li><li>矩阵矩阵左乘右乘一个零矩阵得到的都是零矩阵</li></ul><h4 id="矩阵乘法不满足三规律容易错误">*矩阵乘法不满足三规律(容易错误)</h4><ul><li>AB=O不能推出A=O或B=O</li><li>AB=AC,A≠O不能推出B=C</li><li>AB≠BA，AB有意义,BA不一定有意义</li></ul><p>(若AB=BA，说明AB可交换，可交换的必要条件是m=n，p=q)</p><p>(所以算矩阵方程时要注意相乘的位置)</p><h4 id="矩阵的幂运算">矩阵的幂运算</h4><p>矩阵具有幂运算的前提是，A是一个n阶方阵 <span class="math display">\[A^{k}=\underbrace{AA\cdots{A}}_{k}\\{}\\A^{k_{1}}A^{k_{2}}=A^{k_1+k_2}\\{(A^{k_1})}^{k_2}=A^{k_{1}k_{2}}\\{但是要注意，因为矩阵乘法不满足交换律(AB=BA)，一般情况\\下,下列公式是不成立的}\\(AB)^{k}\neq{A^kB^k}\\(A+B)^2\neq{A^2+2AB+B^2}\\(A+B)(A-B)\neq{A^2-B^2}\\由于AE=EA,下列公式是成立的\]</span> <strong>特殊地，因为AE=EA,下列公式是成立的</strong> <span class="math display">\[(AE)^{k}={A^kE^k}\\(A+E)^2={A^2+2AE+E^2}\\(A+E)(A-E)={A^2-E^2}\\\]</span></p><h2 id="矩阵转置">3、矩阵转置</h2><p>矩阵同序列的行换成同序列的列 <span class="math display">\[a_{ij}=a_{ji}\]</span></p><h3 id="运算律">运算律：</h3><p>设A和B和C为同形矩阵： <span class="math display">\[{(A^{T})}^{T}=A\\{(A+B)}^{T}=A^{T}+B^{T}\\(AB)^{T}=B^TA^T\\{(kA)}^T=kA^T\]</span> <strong>(注意第一条和第三条)</strong></p><p>推广： <span class="math display">\[(A+B+C)^T=A^T+B^T+C^T\\(A_1A_2A_3A_4)^T={A_4}^T{A_3}^T{A_2}^T{A_1}^T\]</span></p><h3 id="对称矩阵和反对称矩阵及其转置特殊方阵">对称矩阵和反对称矩阵及其转置(特殊方阵)</h3><p><span class="math display">\[\begin{align}&amp;对称矩阵满足a_{ij}=a_{ji},满足A^T=A\\&amp;设有A,B两个同阶对称方阵\\&amp;(A+-B)^T=A^T+-B^T\\&amp;(AB)^T=B^TA^T=BA\neq{AB}\\&amp;{一般来说，对称矩阵相乘，结果不是对称矩阵}\\&amp;定理:若AB对称\Leftrightarrow{AB可交换}(看32)\end{align}\]</span></p><p>（反对称矩阵与叉乘有关）</p><h2 id="逆矩阵">4、逆矩阵</h2><p><strong>tips：不要把矩阵放在分母上</strong></p><p>​ <strong>逆矩阵便是线性代数中构造的逆元</strong></p><h3 id="方阵的行列式">1、方阵的行列式</h3><p><span class="math display">\[A=\left(    \begin{matrix}        a_{11}&amp;a_{12}&amp;\cdots&amp;a_{1n}\\        a_{21}&amp;a_{22}&amp;\cdots&amp;a_{2n}\\        \vdots&amp;\vdots&amp;\ddots&amp;\vdots\\        a_{n1}&amp;a_{n2}&amp;\cdots&amp;a_{nn}    \end{matrix}\right)\quad|A|=\left|    \begin{matrix}        a_{11}&amp;a_{12}&amp;\cdots&amp;a_{1n}\\        a_{21}&amp;a_{22}&amp;\cdots&amp;a_{2n}\\        \vdots&amp;\vdots&amp;\ddots&amp;\vdots\\        a_{n1}&amp;a_{n2}&amp;\cdots&amp;a_{nn}    \end{matrix}\right|\\\]</span></p><h3 id="方针行列式性质">方针行列式性质</h3><p><span class="math display">\[|A^T|=|A|\\|kA|=k^n|A|\\|AB|=|A||B|(多个方阵亦成立)\]</span></p><h3 id="伴随矩阵">2、伴随矩阵</h3><p><strong>tips：只有方阵有伴随矩阵</strong></p><p>设存在n阶方阵，A_ij为|A|中a_ij的代数余子式 <span class="math display">\[A=(a_{ij})=\widetilde{A}=\left(    \begin{matrix}    a_{11}&amp;a_{12}&amp;a_{13}&amp;\cdots&amp;a_{1n}\\    a_{21}&amp;a_{22}&amp;a_{23}&amp;\cdots&amp;a_{2n}\\    \vdots&amp;\vdots&amp;\vdots&amp;\ddots&amp;a_{3n}\\    a_{n1}&amp;a_{n2}&amp;a_{n3}&amp;\cdots&amp;a_{nn}    \end{matrix}\right)\]</span> 则A的伴随矩阵为，<strong>(按行求，按列放)</strong> <span class="math display">\[A^*=\left(    \begin{matrix}    A_{11}&amp;A_{21}&amp;A_{31}&amp;\cdots&amp;A_{n1}\\    A_{12}&amp;A_{22}&amp;A_{32}&amp;\cdots&amp;A_{n2}\\    \vdots&amp;\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\    A_{1n}&amp;A_{2n}&amp;A_{3n}&amp;\cdots&amp;A_{nn}    \end{matrix}\right)\]</span></p><h3 id="伴随矩阵性质">伴随矩阵性质</h3><p><span class="math display">\[AA^{*}=A^{*}A=|A|E\\(证明参考行列式中的异乘定理)\\A^{-1}=\frac{1}{|A|}A^*\\|A^*|=|A|^{n-1}(不管|A|等不等于0，证明)\\{(A^*)}^*\quad{ {(A^*)}^*}^*的结果?\]</span></p><h3 id="逆矩阵-1">3、*逆矩阵</h3><h4 id="定义-1">定义</h4><p>设A为n阶方阵，如果存在n阶方阵B使得，AB=BA=E(为n阶单位方阵)</p><p>则称A是可逆的，B为A的逆矩阵，不存在B称A不可逆 <span class="math display">\[记A的逆矩阵为A^{ -1 }\]</span> <strong>注意：</strong></p><ul><li>未必所有方阵可逆</li><li>可逆的方阵，逆矩阵唯一</li></ul><p><strong>唯一性证明：</strong>设AB=E,AC=E，则C=C6yE=C(AB)=(CA)B=B</p><h4 id="性质-1">性质</h4><p><span class="math display">\[\begin{align}&amp;若A可逆，则A^{-1},且{(A^{-1})}^{-1}\\&amp;若A_1,A_2,\cdots,A_s可逆，则他们的乘积也可逆，并且{(A_1A_2A_3\cdots{A})}={A_1}^{-1}{A_2}^{-1}\cdots{A_s}^{-1}\\&amp;若A可逆，则A^T也可逆，且(A^T)^{-1}={(A^{-1})}^T\end{align}\]</span></p><h4 id="如何判断可逆">如何判断可逆</h4><p><strong>tips：若方阵|A|≠0，则称该矩阵非奇异，非退化，满秩，可逆</strong></p><p>判断定理：</p><ol type="1"><li><p>若矩阵A有全零行(或全零列)，那么矩阵A一定不可逆</p></li><li><p>A可逆的充要条件为|A|≠0 <span class="math display">\[A^{-1}=\frac{1}{|A|}A^*\]</span></p></li></ol><h4 id="逆矩阵怎么求">逆矩阵怎么求</h4><p>定义中的推论：A,B都是n阶方针，AB=E或BA=E，证明其中一个即可说明B是A的逆矩阵</p><ul><li>伴随矩阵法（很少用）</li><li>初等变换法（更常用）</li></ul><p><strong>(解矩阵方程常用)</strong></p><h2 id="分块矩阵">5、分块矩阵</h2><p>注意分块矩阵的划分是直来直去的，</p><h3 id="分块矩阵的运算">分块矩阵的运算</h3><p>分块矩阵的运算，要求A和B的划分方式要让A,B每个字块可加，可乘</p><ul><li>加法A+B(保证对应的两个子块规格相同)</li><li>数乘kA</li><li>乘法AB(A的列分块方式和B的行分块方式保持一致)</li></ul><h3 id="分块矩阵的行列式运算">*分块矩阵的行列式运算</h3><p>(拉普拉斯展开定理) <span class="math display">\[|H|=\left|    \begin{matrix}    A&amp;C\\    O&amp;B\\    \end{matrix}\right|=|A||C|\]</span> 这个定理，不是把子块当作元素求出，而是用拉普拉斯展开定理证得。(看<a href="https://ccjou.wordpress.com/2013/06/07/%E5%88%86%E5%A1%8A%E7%9F%A9%E9%99%A3%E7%9A%84%E8%A1%8C%E5%88%97%E5%BC%8F/">相关网站</a>）</p><h3 id="分块矩阵的转置">分块矩阵的转置</h3><p>实现步骤：</p><ul><li>把子块当做元素进行转置</li><li>把每个子块进行转置</li></ul><h3 id="分块对角阵">分块对角阵</h3><h2 id="矩阵的初等变换和初等矩阵">6、矩阵的初等变换和初等矩阵</h2><h3 id="初等行变换">初等行变换</h3><ul><li><p>交换两行 <span class="math display">\[r_i\rightarrow{r_j}(交换i，j两行)\]</span></p></li><li><p>某一行乘以非零数k <span class="math display">\[kr_{i}(k\neq0)\]</span></p></li><li><p>将矩阵某一行的倍数加到另一行 <span class="math display">\[r_j+kr_{i}(将矩阵第i行的k倍加到第j行)\]</span></p></li></ul><p><strong>将"行"换成"列"即可得到 初等列变换 的定义</strong></p><p>显然，三种变换都是 <strong>可逆</strong> 的。</p><h3 id="初等行变换后-矩阵行列式的变化">初等行变换后 矩阵行列式的变化</h3><p>矩阵进行初等行变化之后，发生了变化，但还是那个矩阵</p><p>当|A|是方阵时，进行初等行变化会有以下性质(</p><ul><li>对换定理，交换两行，行列式变号</li><li>倍乘定理，k乘以某一行，行列式乘以k</li><li>倍加定理，行列式不变</li></ul><p>初等行变化的本质是对矩阵的变化，但矩阵还是那个矩阵，但行列式发生了变化(初等变换下，矩阵和行列式的关系)</p><h3 id="初等变换的性质">初等变换的性质</h3><ul><li>自反性</li><li>对称性</li><li>传递性</li></ul><h3 id="阶梯形矩阵和标准形">*阶梯形矩阵和标准形</h3><p>定理：任意矩阵可以通过有限次初等变化化成标准形(行变化，列变化，或者组合)</p><figure><img src="D:/Myblog/bbksi1014.github.io/Blog/source/_posts/%E7%BA%BF%E4%BB%A3Note.assets/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAeWt6Y3MyMDAw,size_20,color_FFFFFF,t_70,g_se,x_16.png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>行最简形矩阵</p><figure><img src="D:/Myblog/bbksi1014.github.io/Blog/source/_posts/%E7%BA%BF%E4%BB%A3Note.assets/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAeWt6Y3MyMDAw,size_20,color_FFFFFF,t_70,g_se,x_16-16502687454271.png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>标准形矩阵</p><figure><img src="D:/Myblog/bbksi1014.github.io/Blog/source/_posts/%E7%BA%BF%E4%BB%A3Note.assets/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAeWt6Y3MyMDAw,size_20,color_FFFFFF,t_70,g_se,x_16-16502687454272.png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h3 id="初等方针">初等方针</h3><p>对n阶单位矩阵E实施一次初等变换得到的矩阵称为n阶初等矩阵</p><p>$$ <span class="math display">\[\begin{align}4x4单位矩阵举例:E&amp;=\left(    \begin{matrix}        1&amp;&amp;&amp;\\         &amp;1&amp;&amp;\\         &amp;&amp;1&amp;\\         &amp;&amp;&amp;1\\    \end{matrix}\right)\\E(i,j)&amp;=\left(    \begin{matrix}         &amp;1&amp;&amp;\\         1&amp;&amp;&amp;\\         &amp;&amp;1&amp;\\         &amp;&amp;&amp;1\\    \end{matrix}\right)(i=2,j=1)\\E(i(k))&amp;=\left(    \begin{matrix}        1&amp;&amp;&amp;\\         &amp;5&amp;&amp;\\         &amp;&amp;1&amp;\\         &amp;&amp;&amp;1\\    \end{matrix}\right)(i=2,k=5)\\E(i(k),j)&amp;=\left(    \begin{matrix}             &amp;5&amp;&amp;\\         1&amp;&amp;&amp;\\         &amp;&amp;1&amp;\\         &amp;&amp;&amp;1\\    \end{matrix}\right)(i=2,k=5,j=1)\end{align}\]</span> <span class="math display">\[易得，初等矩阵都是可逆的，且初等矩阵的逆矩阵是同一类形初等方阵即\]</span> {E(i,j)}^{-1}=E(i,j) \ {E(i(k))}^{-1}=E(i()) \ {E(i(k),j))}^{-1}=E(i(-k),j) $$ <strong>初等方针是用来描述初等变化的矩阵算子</strong></p><p>左行右列(变换算子代表的是初等行变换的时候)</p><h3 id="方阵可逆的判别条件根据初等矩阵和初等变换">方阵可逆的判别条件(根据初等矩阵和初等变换)</h3><p><span class="math display">\[\begin{align}&amp;任意矩阵可以通过有限次初等变换化成标准型\\&amp;定理1:任意矩阵A存在有限个初等矩阵(行变化初)P_1,P_2,P_3,\cdots,{P_s},(列变化)Q_1,Q_2,Q_3,\cdots{Q_t},\\&amp;使得P_1P_2P_3\cdots{P_s}AQ_1Q_2Q_3\cdots{Q_t}为标准型\\&amp;推论:A,B等价\Leftrightarrow存在可逆据矩阵P，Q,使得PAQ=B\\&amp;定理2:A可逆\Leftrightarrow{A的标准型为E(单位矩阵)}\\&amp;定理3:A可逆\Leftrightarrow{A={P_1}^{-1}{P_2}^{-1}\cdots{P_s}^{-1}}{Q_1}^{-1}{Q_2}^{-1}{Q_3}^{-1}\cdots{Q_t}^{-1}\end{align}\]</span></p><p>上述定理可以总结为： <span class="math display">\[n阶方阵可逆\Leftrightarrow方阵A行等价于n阶单位矩阵E\Leftrightarrow方阵A可以表示为一些初等方阵的乘积\]</span></p><h3 id="初等变化法的具体方法">初等变化法的具体方法</h3><ol type="1"><li>首先构造分块矩阵(A|E)</li><li>对分块矩阵实施初等行变换，将该分块矩阵化成行最简形矩阵</li><li>判断：如果A不能行等价于单位矩阵E，则矩阵A不可逆（或者说A块出现全零行）；如果A能行等价于E(A块没有全零行)，则A可逆，E块就行等价于A-1（即E块部分就是所求逆矩阵）</li></ol><p>注意：</p><p>化阶梯形时，对第一行，第二行，第三行的阶梯化简，要依次进行，整行进行操作</p><h2 id="矩阵的秩与向量组的秩不同">7、矩阵的秩（与向量组的秩不同）</h2><h3 id="定义-2">定义</h3><p>mxn的矩阵A，其<strong>非零子式的最高阶数</strong>就是A的秩，记r(A)</p><h3 id="性质-2">性质</h3><p>1、对于矩阵A_mxn</p><p>0≤r(A)≤min{m,n}</p><p>满秩：r(A)=m,称为行满秩；r(A)=n，称为列满秩</p><p>降秩：r(A)&lt;min(m,n)</p><p><strong>注意：</strong>对于n阶方阵，若其满秩r(A)=n,即该方阵的n阶子式不等于0，意味着该方阵的行列式不等于0，该方阵可逆</p><p>2、r(A)=r(A^T)</p><p>3、初等变换不改变矩阵的秩</p><p>4、矩阵乘以可逆矩阵，秩不变</p><p>*<strong>性质4的推论：</strong>P为m'阶可逆方阵，Q为n阶可逆方阵</p><p>r(A)=r(PA)=r(AQ)=r(PAQ)</p><p><strong>定理：</strong>r(A)=r 等价于 有一个r阶子式不为0，r以上的高阶子式都为0</p><p>(代数余子式展开即可)</p><h3 id="阶梯形矩阵">*阶梯形矩阵</h3><figure><img src="D:/Myblog/bbksi1014.github.io/Blog/source/_posts/%E7%BA%BF%E4%BB%A3Note.assets/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAeWt6Y3MyMDAw,size_20,color_FFFFFF,t_70,g_se,x_16.png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>左起首非零元的零的个数按行的增加而严格增加</p><p><strong>阶梯形矩阵判断：</strong>横线可跨多个列，竖线只跨一个数</p><h3 id="行最简化阶梯形矩阵">*行最简化阶梯形矩阵</h3><p>运用到的地方：极大相关组极其线性表示，解线性方程组（高斯消元法），矩阵方程，特征值和特征向量（就是求矩阵方程）</p><p><strong>定义：</strong></p><figure><img src="D:/Myblog/bbksi1014.github.io/Blog/source/_posts/%E7%BA%BF%E4%BB%A3Note.assets/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAeWt6Y3MyMDAw,size_20,color_FFFFFF,t_70,g_se,x_16-16502687454271.png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p><strong>三步走判断：</strong></p><ul><li>折线判断阶梯形</li><li>首非零元1画竖线</li><li>非零元所在列其余元素是0</li></ul><h3 id="矩阵的秩判断和线性表示">矩阵的秩判断和线性表示</h3><p><strong>定理1:</strong>矩阵的初等变换(行和列皆可以）不改变矩阵的秩</p><p><strong>定理2：</strong>矩阵通过初等变化变成阶梯形矩阵，矩阵的秩等于其非零行的行数</p><h1 id="向量">向量</h1><h2 id="定义-3">定义</h2><p>由n个数a1，a2,……,an组成的有序数组称为n维向量，写成 <span class="math display">\[\left(    \begin{matrix}    a_1\\    a_2\\    \vdots\\    a_n    \end{matrix}\right)或(a_1,a_2,\cdots,a_n)\]</span> 分量都是0的称为零向量</p><h2 id="向量的运算">向量的运算</h2><ul><li>相加相减</li><li>数乘</li><li>内积</li><li>外积</li></ul><h2 id="向量组及其线性关系">向量组及其线性关系</h2><h3 id="定义-4">定义</h3><p>由n个维度相同的向量构成的集合，称为向量组</p><p>一个矩阵可以表示成一个向量组，建立一 一对应的关系 <span class="math display">\[A=\left(    \begin{matrix}    a_{11}&amp;a_{12}&amp;a_{13}&amp;\cdots&amp;a_{1n}\\    a_{21}&amp;a_{22}&amp;a_{23}&amp;\cdots&amp;a_{2n}\\    \vdots&amp;\vdots&amp;\vdots&amp;\ddots&amp;a_{3n}\\    a_{n1}&amp;a_{n2}&amp;a_{n3}&amp;\cdots&amp;a_{nn}    \end{matrix}\right)=\left(    \begin{matrix}    \beta^T_1\\    \beta^T_2\\    \vdots\\    \beta^T_n    \end{matrix}\right)=(\alpha_1,\alpha_2,\cdots,\alpha_n)\\(\alpha_j为列向量，\beta_i为行向量)\]</span></p><h3 id="向量组的等价">向量组的等价</h3><p>两个同维向量组可以相互线性表示，称两向量组等价</p><p>(与矩阵等价的定义作比较)</p><p>性质：</p><ul><li>反身性</li><li>对称性</li><li>传递性</li></ul><h3 id="线性相关和线性无关">线性相关和线性无关</h3><h4 id="线性相关">线性相关</h4><p><span class="math display">\[存在一组不全为0的数k_1,k_2,\cdots,k_n,使得k_1\alpha_1+k_2\alpha_2+\cdots+k_n\alpha_n=0\]</span></p><h4 id="线性无关">线性无关</h4><p><span class="math display">\[找不到(不存在）一组不全为0的数k_1,k_2,\cdots,k_n,使得k_1\alpha_1+k_2\alpha_2+\cdots+k_n\alpha_n=0，只有全为0的解\]</span></p><h4 id="性质-3">性质：</h4><ol type="1"><li><p>向量组中两个向量成比例，该向量组必线性相关</p></li><li><p>一个零向量必相关</p></li><li><p>含零向量的任意向量组必相关</p></li><li><p>一个非零向量必无关</p></li><li><p>一个向量组线性相关，那么加上几个同维向量，向量组依旧线性相关（部分组相关，则整体组相关；整体组无关，部分组无关）</p></li><li><p>线性无关的向量组，其接长向量组线性无关</p><p>线性相关的向量组，其截短向量组线性相关(逆否）</p><p>(这里接长和截短是对向量的维度分量的，从线性方程组证明)</p></li><li><p>n个n维向量组成向量组，D≠0等价于向量组线性无关；</p><p>D=0等价于向量组线性相关</p></li></ol><h3 id="线性相关的相关定理">线性相关的相关定理</h3><p><span class="math display">\[\begin{align}&amp;\alpha_1,\cdots,\alpha_s相关\Leftrightarrow\beta可以由至少有一个向量由其余向量表示\\&amp;\alpha_1,\cdots,\alpha_s，\beta无关\Leftrightarrow\beta可以由\alpha_1,\cdots,\alpha_s唯一线性表示\\&amp;*替换定理:\alpha_1,\cdots,\alpha_s无关，可由\beta_1，\cdots,\beta_t表示,则s&lt;=t\\&amp;逆否:\alpha_1,\cdots,\alpha_s可由\beta_1，\cdots,\beta_t表示，s&gt;t，则\alpha_1,\cdots,\alpha_s线性相关\\&amp;*若向量的个数m大于向量的维数n，m&gt;n，则该m个向量必线性相关\\&amp;推论:两个等价的线性无关组所含向量的个数是相同的\end{align}\]</span></p><h2 id="向量组的秩">向量组的秩</h2><h3 id="极大线性无关组和秩">极大线性无关组和秩</h3><h4 id="极大线性无关组定义">极大线性无关组定义</h4><p><span class="math display">\[在一个n维向量组中取出s个向量\alpha_1,\cdots,\alpha_s\\\alpha_1,\cdots,\alpha_s线性无关，向量组其余向量都可以由这s个向量线性表示，\\则称这s个向量为该向量组的极大线性无关组\]</span></p><p><strong>向量组的秩即对应的极大线性无关组的个数</strong></p><p>(与矩阵的秩定义------非零子式的最高阶数 是不同的，但有联系)</p><h4 id="性质-4">性质</h4><p>对于一个向量组（α1，……，αs）</p><ul><li>0≤r（α1，……，αs）≤{向量的个数，维度数}</li><li>α1，……，αs 无关 等价于 r=s</li><li>α1，……，αs 相关 等价于 r&lt;s</li></ul><h4 id="相关定理">相关定理</h4><p>1，任意向量与对应极大线性无关组等价</p><p>2，等价的向量组秩相等（等价传递性）</p><p>3、一个向量组线性无关的充要条件是它的秩等于向量的个数</p><h3 id="矩阵的行秩和列秩">矩阵的行秩和列秩</h3><p>矩阵的行秩=矩阵的列秩=矩阵的秩r(A)</p><p>(非零子式的最高阶数)</p><p>r(AB)≤min{r(A),r(B)}</p><h3 id="求极大线性无关组及线性表示">求极大线性无关组及线性表示</h3><p>引理：矩阵仅作初等<strong>行变化</strong>不改变矩阵<strong>列向量</strong>之间的线性关系</p><p>也就是说，初等行变化之后，无关依旧无关，相关依旧相关</p><p><strong>求解步骤：</strong></p><ol type="1"><li>按列向量构成矩阵</li><li>只做初等行变换，化成最简化阶梯形</li><li>首非零元1所在列即是极大线性无关组</li><li>其余向量的线性表示用从行简化阶梯形直接对应读出</li></ol><figure><img src="C:\Users\L\OneDrive\桌面\开学文件\Typora%20Note\线代Note.assets\image-20220320124851567.png" alt="image-20220320124851567" /><figcaption aria-hidden="true">image-20220320124851567</figcaption></figure><h2 id="线性方程组有解判定4">线性方程组有解判定4</h2><p>首先将增广矩阵化成行最简化形 <span class="math display">\[\begin{align}&amp;系数矩阵{A}=\left(    \begin{matrix}    a_{11}&amp;a_{12}&amp;a_{13}&amp;\cdots&amp;a_{1n}\\    a_{11}&amp;a_{12}&amp;a_{13}&amp;\cdots&amp;a_{2n}\\    \vdots&amp;\vdots&amp;\vdots&amp;\ddots&amp;a_{3n}\\    a_{11}&amp;a_{12}&amp;a_{13}&amp;\cdots&amp;a_{mn}    \end{matrix}\right)\\&amp;增广矩阵\widetilde{A}=\left(    \begin{matrix}    a_{11}&amp;a_{12}&amp;a_{13}&amp;\cdots&amp;a_{1n}&amp;b_{1}\\    0&amp;a_{12}&amp;a_{13}&amp;\cdots&amp;a_{2n}&amp;b_{1}\\    \vdots&amp;\vdots&amp;\vdots&amp;\ddots&amp;a_{3n}&amp;\vdots\\    0&amp;0&amp;0&amp;\cdots&amp;a_{mn}&amp;b_{1}    \end{matrix}\right)\\&amp;当r(A)=r(\widetilde{A})=n,有唯一解\\&amp;当r(A)=r(\widetilde{A})&lt;n,有无穷多解\\&amp;当r(A)\neq{r(\widetilde{A})},无解\\&amp;(n是向量组向量个数，或未知数个数)\end{align}\]</span> 方程组m，n（m是方程个数，n是未知量个数）</p><p><strong>判断流程：</strong></p><ol type="1"><li><p>写出增广系数矩阵</p></li><li><p>只做初等行变化，化为<u>行阶梯型</u></p></li><li><p>看r(A)与r(A~是否相等)，相等有解，不相等无解</p></li><li><p>有解的话，化<u>最简化阶梯型</u>，<strong>写出一般解</strong>，<strong>标出自由变量</strong></p><p>(基础解系)</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>note</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>极限</title>
    <link href="/2022/04/18/%E6%9E%81%E9%99%90/"/>
    <url>/2022/04/18/%E6%9E%81%E9%99%90/</url>
    
    <content type="html"><![CDATA[<h1 id="极限">极限</h1><h1 id="数列极限基础">数列极限（基础）</h1><h2 id="极限定义的理解">极限定义的理解</h2><p>极限的数学定义应该是精确地 可定义的</p><p>e--&gt;N不是函数关系;</p><p>我们研究的是无穷序列，数列有极限就是在一定的e精确度下，存在N,让n&gt;N的无限多项存在于极限a的邻域内（<strong>在无穷的层面中也就是数列的基本全部项在邻域内</strong>，也就是趋近于某个值）;</p><p>换个说法，数列有有限项在领域外，意味着存在N让n&gt;N时，数列全部位于邻域内;</p><p>注意，一定是n&gt;N时，数列所有的项在邻域，这样才是保证了无穷数列基本完全处于邻域内;<strong>而数列有无穷多项处于邻域内数列就有极限的说法是错误的</strong>，应该是<strong>足够后面的所有的项</strong>都处在某个邻域内，无穷多项有可能只是后面所有项的一部分项。</p><figure><img src="C:\Users\L\OneDrive\桌面\开学文件\Typora%20Note\极限.assets\image-20210922091516811.png" alt="image-20210922091516811" /><figcaption aria-hidden="true">image-20210922091516811</figcaption></figure><p>例子</p><figure><img src="C:\Users\L\OneDrive\桌面\开学文件\Typora%20Note\极限.assets\image-20210922091550549.png" alt="image-20210922091550549" /><figcaption aria-hidden="true">image-20210922091550549</figcaption></figure><h2 id="极限证明的基本思路">极限证明的基本思路</h2><p>从极限存在的假设出发，以极限的定义为基础，观察数列解析式的性质，在数值或者变化范围的观点上(放缩的思路)，构造e从而证明N的存在性，进而便证明了极限的存在。</p><h2 id="极限的静态定义和动态定义">极限的静态定义和动态定义</h2><p>静态定义：</p><figure><img src="D:/Myblog/bbksi1014.github.io/Blog/source/_posts/%E6%9E%81%E9%99%90.assets/v2-f21285f2f94f0d62ea0325ae53a05d7a_720w.jpg" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>动态定义：</p><p><img src="D:/Myblog/bbksi1014.github.io/Blog/source/_posts/%E6%9E%81%E9%99%90.assets/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202021-09-15%20105552.png" /></p><p>我们所学的极限定义是从e的静态层面(给定精确度)之后进行分析，这种定义可以让我们以（e，N）能够定量对数列极限的存在进行精确分析。</p><h2 id="收敛数列的性质">收敛数列的性质</h2><ul><li>唯一性（收敛数列极限唯一）</li><li>有界性（收敛必定有界，有界不一定收敛）</li><li>保号性（极限数列可以反映数列的符号，数列的符号也可以反映极限的符号）</li></ul><p>数列收敛等价于数列存在极限</p><p>数列的保号性的强结论推导</p><h2 id="收敛数列和其子列的关系">收敛数列和其子列的关系</h2><p>原数列数列收敛，则其任意子列也收敛，且极限相同;</p><p>存在子列发散，则其原数列也发散</p><p>（可用于判别数列发散）</p><h1 id="函数的极限数列极限在函数中推广">函数的极限（数列极限在函数中推广）</h1><p>函数中的无穷符号要注明正负，数列本身已经将无穷定义为正</p><p>从离散到连续</p><p>三角不等式</p><h2 id="函数极限和数列极限的定义的异同">函数极限和数列极限的定义的异同</h2><p>函数的有界性和保号性是局部的 <span class="math display">\[\mathring{U}(1,2)\]</span></p><h2 id="复合函数的极限运算法则理解">复合函数的极限运算法则理解</h2><figure><img src="C:\Users\L\OneDrive\桌面\开学文件\Typora%20Note\极限.assets\image-20210922085858832.png" alt="image-20210922085858832" /><figcaption aria-hidden="true">image-20210922085858832</figcaption></figure><figure><img src="C:\Users\L\OneDrive\桌面\开学文件\Typora%20Note\极限.assets\image-20210922090838949.png" alt="image-20210922090838949" /><figcaption aria-hidden="true">image-20210922090838949</figcaption></figure><p>对法则约束条件 <span class="math display">\[x\in\mathring{U}({x_0},{\epsilon_0}),g(x)≠u_0\]</span> 的解释:</p><p>​ 从极限的定义上来看，对于内函数 <span class="math display">\[u=g(x)\]</span></p><p>​ 来说，若 <span class="math display">\[x\rightarrow{x_0},limg(x)=u_0\]</span> ​ 那么 <span class="math display">\[x\in\mathring{U}({x_0},{\epsilon_0})，u≠g(x)\]</span> ​ <strong>这样才符合极限存在的定义</strong></p><p>详细来说，便是：<strong>不能忽略中间变量u=g(x)的变化</strong> <span class="math display">\[\begin{align}&amp;对于复合函数的极限运算法则:\\&amp; \lim_{x\rightarrow{x_0}}f[g(x_0)]=\lim_{x\rightarrow{u_0}}f(u)=A\\&amp;该法则让我们可以可以通过换元的方式求取复合函数的极限，而该法则是有约束条件的(详情见书)，\\&amp;该约束条件意味着要想应用这条法则，复合函数应满足x\rightarrow{x_0}时，u=g(x)\rightarrow{u_0}(这包含着\\&amp;逼近但不等于u_0的意思)当x\rightarrow{x_0}时，或者说x\in\mathring{U}({x_0},{\epsilon_0})时，内函数u=g(x)的取值&amp;变化可能是:\\  &amp;1,\lim_{x\rightarrow{x_0}}\\  &amp;2,存在x=x_0使得f(x)=u_0或f(x)恒等于某个值u_0\\&amp;u的变化会因为x的控制而发生改变，变得无法逼近目标u_0,因此我们需要观察x的变化取判断u的变化，\\&amp;再去判断f(u)的u受到x控制后是否还能向u_0逼近，若符合第一种情况则该法则可用，\\&amp;若符合第二种情况则该法则不适用\\&amp;因为u\rightarrow{u_0}时，外函数的极限与u_0的取值无关，存在\lim_{u\rightarrow{u_0}}f(u)≠f(u_0)或f(u_0)不存在的情况,\\&amp;忽视约束条件运用该法则有可能取到的是f(u_0)的值,而不是当x\rightarrow{x_0}时,f(g(x))的极限值，\\&amp;因为我们忽视了中间变量u的变化情况，u有可能并不是随着x的逼近,逼近于u_0,而是会恒等于u_0或者u=f(x)\\&amp;甚至u=g(x)不存在极限,这时我们会取不到f(u)的极限值;\\&amp;我们并不是单纯得代入某个值给u，而是要观察u随着x的逼近\\&amp;得到u的变化情况，如果u逼近于某个值，则f(u)便有机会取到某个极限值，但不一定是f(u)\end{align}\]</span></p><h2 id="极限求值的技巧">极限求值的技巧</h2><p>做之前先观察极限 最好能得出极限的大概值</p><ul><li><p>分子或分母的有理化</p><p><strong>常用公式:</strong> <span class="math display">\[\begin{align}x^{n}-1&amp;=(x-1)(x^{n-1}+x^{n-2}+\dots+x+1)\\x&amp;=(\sqrt[n]{x+1})^{n}-1=(\sqrt[n]{x+1}-1)((\sqrt[n]{x+1})^{n-1}-(\sqrt[n]{x+1})^{n-2}+\dots+(\sqrt[n]{x+1})+1)\end{align}\]</span> <strong>同时,n次方的差公式为</strong> <span class="math display">\[\begin{align}a^2-b^2&amp;=(a-b)(a+b)\\a^3-b^3&amp;=(a-b)(a^2+ab+b^2)\\a^{n}-b^{n}&amp;=(a-b)(a^{n-1}+a^{n-2}b+a^{n-3}n^{n-2}+\dots+a^{2}b^{n-3}+ab^{n-2}+b^{n-1})\end{align}\]</span></p></li><li><p>取分式</p></li><li><p>换元</p></li><li><p>无穷小和无穷大乘以有界函数的定理</p></li></ul><p><strong>注意</strong>：<strong>无穷小x有界函数依旧是无穷小</strong></p><p>​ <strong>无穷大x有界函数不一定是无穷大</strong></p><p>如： <span class="math display">\[x\sin{\frac{1}{x}}\]</span> 运用夹逼准则证明极限的存在的话 要根据我们对极限的猜测 去构造两条逼近边界</p><p><strong>极限求值不等式：</strong> <span class="math display">\[[x]&gt;x+1\\绝对值不等式：\\||a|-|b||&lt;=|a+-b|&lt;=|a|+|b|\]</span></p><h1 id="无穷小的比较">无穷小的比较</h1><p>无穷小的阶数k是用来描述无穷小趋近于0的变化快慢 要<strong>大于0</strong> <span class="math display">\[\alpha(x)^k\]</span> <strong>无穷小替换法则只能替换因式，加减式不能替换</strong></p><p><strong>从泰勒展开公式</strong> <span class="math display">\[f(x)=f(x_0)+\frac{f^{(1)}(x_0)}{1!}+\frac{f^{(2)}(x_0)}{2!}+\dots+\frac{f^{(n)}(x_0)}{n!}+R_n(x)\\佩亚诺余项：R_n(x)=o[(x-x_0)^n]\\拉格朗日余项：R_n(x)=f^{n+1}[x_0+\theta(x-x_0)]\frac{(x-x_0)^{n+1}}{(n+1)!}\]</span> <strong>我们可以得知，我们替换等价无穷小时（一般替换成x^n），</strong></p><p><strong>其实是取 被替换的f(x) 的粗略展开，也就是f(x)泰勒展开的第一项往后的一部分项</strong></p><figure><img src="D:/Myblog/bbksi1014.github.io/Blog/source/_posts/%E6%9E%81%E9%99%90.assets/v2-8d85d36c6b00dd2c97e9921c88e0398b_r.jpg" alt="preview" /><figcaption aria-hidden="true">preview</figcaption></figure><p><strong>当我们用加减时，有可能将一部分更高阶的无穷小给忽略掉，导致结果出错</strong></p><p><strong>但有时候加减也可以，在比较无穷小的阶数时，只要更低阶的无穷小没有因为加减而消去，则可以对加减式进行无穷小的替换；但是计算极限时会不能替换</strong></p><figure><img src="C:\Users\L\OneDrive\桌面\开学文件\Typora%20Note\极限.assets\image-20210926105256381.png" alt="image-20210926105256381" /><figcaption aria-hidden="true">image-20210926105256381</figcaption></figure>]]></content>
    
    
    
    <tags>
      
      <tag>learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二进制编码和计算机存储</title>
    <link href="/2022/04/17/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E7%A0%81%E5%92%8C%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%98%E5%82%A8/"/>
    <url>/2022/04/17/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E7%A0%81%E5%92%8C%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%98%E5%82%A8/</url>
    
    <content type="html"><![CDATA[<p>参考资料：计算机科学导论 汇编原理（王爽）</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;bbski&#x2F;bbski1014.github.io@latest<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><h1 id="关于二进制编码和存储知识">关于二进制编码和存储知识</h1><p>参考资料：计算机科学导论 汇编原理（王爽）</p><p>视频<a href="https://www.bilibili.com/video/BV1ni4y1G7B9?p=10">狂神说</a></p><h3 id="进制转换">1，进制转换</h3><h4 id="进制只是一种对数字的编码方式">进制只是一种对数字的编码方式</h4><p>​ 我们因为身边的客观事物（10根手指）对十进制数字编码更为熟悉，但数的概念是独立的，数的运算法则是完备的，而进制只是数的表达方式，所以每一种进制在数字的运算法则上完备的。</p><p>​ 数的任何进制表达都是有序的，就像十进制一样（数表），我们在计算时，有“查数“的思想，就像是在十进制运算中中，我们在运算时其实会调取熟记于心的九九加法表和九九乘法表（这些表记录了十进制个位基本运算）;<strong><em>要想对其他的进制套用十进制的运算模式</em></strong>，我们可以根据其他进制中，亦可以<strong><em>编制一个对应的”加乘表“</em></strong>，用<strong><em>”查数“</em></strong>的思想（或者说查表），即可对不同进制的数进行十进制算数模式的套用;其中减除的运算需要我们可以用加乘的逆运算思想进行匹配，从而得出结果。</p><p>​ 我们要注意我们要对不同进制的“个位数”进行预编码，例如十进制中我们有0-9，二进制中0和1，0-9不够用的我们可以用其他字符来代替，比如16进制我们可以用0-9以及A-F，<strong><em>也就是说只要我们愿意，我们也可以将十进制中的0-9化成其他的字符</em></strong>。</p><p>​ 我们现在用的比较多的进制位2,4,8,16（基数都是2的指数）</p><h4 id="进制的转换重点在于数字编码的位比如十进制的个十百">进制的转换重点在于数字编码的位（比如十进制的个，十，百）</h4><p><strong>a.十进制与其他进制数的转化</strong>（较常用）：</p><p>​ 任何数的进制都可以用<strong>“按权展开”</strong>的方式将不同进制的数转化为十进制（这个权是位权，十进制本身显然）</p><p>​ 十进制数转换为其他的进制可以<strong>对整数部分 除“数”取余</strong>，<strong>对小数部分 乘“数”取整</strong>，直至小数部分为0即可</p><p>（“数”是基数，进制），小数部分最后有可能无法取0，在目标进制中为无限小数。</p><p><strong>b.一种进制的有限小数部分 在另一种进制有可能会变成 无法精确表达的无限小数</strong></p><p>​ 某种进制中的小数在另一种进制中能被有限表达是有条件的————原进制中的小数部分能在目标进制中</p><p>​ 能按权展开，比如0.75（10）可以在二进制中按位权2展开位0.11（2）。</p><p>​ 显然这也导致了，在计算机中，十进制数小数部分在二进制中有可能会不能精确的表达出来;事实上，十进</p><p>​ 制小数基本不会在二进制中被表示成有限小数。</p><p><strong>c.常用的2,4,8（取三合一）,16（取四合一）进制相互之间的转化可以用“合位”的思想</strong></p><p>​ 通常我们会将较长二进制数转化为其他其他的2^n进制，表达更为简短</p><p>​ 八进制数和16进制的相互转化应该使用二进制作为转化中介,因为“合位”的前提在于，合位取的数能在目标进</p><p>​ 进制中能被个位编码表达，八和16进制是无法直接进行“合位”转换的。</p><p><strong>d.小数部分能否按权展开的确定</strong></p><p>​ 我们可以用将原进制转化为十进制，观察数的大小，再看这个小数能否以目标位权进行展开。</p><figure><img src="D:/Myblog/bbksi1014.github.io/Blog/source/_posts/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E7%A0%81%E5%92%8C%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%98%E5%82%A8.assets/20210514113026699-165013343878934.png" alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><h3 id="机器码的编码原码反码一补数补码二补数">2，机器码的编码：原码反码（一补数）补码（二补数）</h3><p><strong>参考资料：</strong></p><p><a href="https://www.cnblogs.com/zhangziqiu/archive/2011/03/30/ComputerCode.html">详解</a> <a href="https://zhuanlan.zhihu.com/p/99082236">较简易解释</a> <a href="https://www.jianshu.com/p/ffc97c4d2306">有关数据溢出</a></p><p><strong>编码法则：</strong></p><figure><img src="D:/Myblog/bbksi1014.github.io/Blog/source/_posts/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E7%A0%81%E5%92%8C%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%98%E5%82%A8.assets/image-20210916130538882-165013343879438.png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p><strong>正数不变，负数要变，符号位需保留。（首位为符号位，0为正，1为负）</strong></p><p><strong>补码为减法而生</strong>，我们为了方便，将机器码的首位设置为符号位，接着开始研究机器码的加减，发现过程中产生了一系列问题，最后用补码的方式解决了。</p><p><strong>负数原码&gt;&gt;反码&gt;&gt;补码的过程实则是：取负数十进制的数值的绝对值，急着按位取反，接着补1，从而得到-1（10）在计算机中的二进制表达</strong>（这个结论可以通过n-x=0的方式来判断）</p><p><strong>补码的生活实例证明是时钟。</strong></p><p><strong>整数型数据在计算机中，用补码表示。</strong></p><p>​ <img src="D:/Myblog/bbksi1014.github.io/Blog/source/_posts/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E7%A0%81%E5%92%8C%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%98%E5%82%A8.assets/201103302155504514-165013343878936.jpg" alt="clip_image001" /></p><figure><img src="D:/Myblog/bbksi1014.github.io/Blog/source/_posts/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E7%A0%81%E5%92%8C%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%98%E5%82%A8.assets/image-20210916135015023-165013343879440.png" alt="image-20210916135015023" /><figcaption aria-hidden="true">image-20210916135015023</figcaption></figure><p>此时, 表盘相当于每128个刻度转一轮. 所以用补码表示的运算结果最小值和最大值应该是[-128, 127]。</p><p>一个数的反码, 实际上是这个数对于一个膜的同余数. 而这个膜并不是我们的二进制, 而是所能表示的最大值! 这就和钟表一样, 转了一圈后总能找到在可表示范围内的一个正确的数值!</p><h3 id="位运算">3.位运算</h3><p><a href="https://www.runoob.com/w3cnote/bit-operation.html">位运算概述</a></p><p><a href="https://zhuanlan.zhihu.com/p/102277869">使用案例</a></p><p>合理使用位运算能 <strong>避免数据的溢出</strong></p><p>​ <strong>加快乘除法的运行速度</strong>（加减法与正常算法速度相当）</p><p>​ 这是因为位运算指令只占用CPU两个运行周期 而 乘除指令占了4个；</p><h2 id="计算机结构基础">2，计算机结构基础</h2><h3 id="计算机三大总线">1，计算机三大总线：</h3><p>CPU要想进行数据读写，达成读取内存地址和操作外设的目的，需要对系统进行信息的交互</p><p>交互的信息有：</p><ul><li>地址信息（存储单位的地址）</li><li>数据信息（器件的选择，读写命令）</li><li>控制信息（读写的数据）</li></ul><p>交互的途径（电信号的传播）：</p><ul><li>地址总线（决定了CPU寻址能力2^n）</li><li>数据总线（决定了CPU单次数据传输量）</li><li>控制总线（决定了CPU对系统其他部件的控制能力）</li></ul><h3 id="cpu读取内存数据的过程">2，CPU读取内存数据的过程</h3><p><strong>物理存储器的分类</strong></p><p>按读写性质可分为：</p><ul><li>随机存储器RAM //挥发性内存，带电读写，断电清空</li><li>只读存储器ROM //非挥发性内存 只读不写 断电内容不丢失</li></ul><p>按功能和连接可分为：</p><ul><li>随机存储器（供CPU使用的大部分数据程序）</li><li>装有BIOS的ROM（存储着供各种外部设备启动的程序）</li><li>接口卡上的RAM（需对大量暂时性数据进行存储，如显卡的显存）</li></ul><p><strong>内存存储空间</strong></p><p>物理存储器看似独立，其实都是与CPU总线相连，CPU通过控制总线对他们发出内存读写命令，所以，CPU把所有的存储器都当内存对待，看做一个有若干存储单元组成的逻辑存储器，这就是所谓的内存地址空间。</p><p><img src="D:/Myblog/bbksi1014.github.io/Blog/source/_posts/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E7%A0%81%E5%92%8C%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%98%E5%82%A8.assets/image-20210916222354918-165013343879439.png" /></p><p><img src="D:/Myblog/bbksi1014.github.io/Blog/source/_posts/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E7%A0%81%E5%92%8C%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%98%E5%82%A8.assets/image-20210916222437567-165013343879442.png" /></p><p><strong>CPU组成</strong></p><ul><li>运算器（信息处理）</li><li>控制器（控制各个器件）</li><li>寄存器（信息存储）</li></ul><p>（可能还有二级高速缓存）</p><p><strong>关于CPU位数</strong>：</p><p><img src="D:/Myblog/bbksi1014.github.io/Blog/source/_posts/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E7%A0%81%E5%92%8C%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%98%E5%82%A8.assets/image-20210916225129979-165013343879441.png" /></p><h2 id="计算机程序运行的虚拟内存">计算机程序运行的虚拟内存</h2>]]></content>
    
    
    
    <tags>
      
      <tag>learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>系统重装PE</title>
    <link href="/2022/04/16/%E7%B3%BB%E7%BB%9F%E9%87%8D%E8%A3%85PE/"/>
    <url>/2022/04/16/%E7%B3%BB%E7%BB%9F%E9%87%8D%E8%A3%85PE/</url>
    
    <content type="html"><![CDATA[<h1 id="重装系统初体验pe">重装系统初体验（PE）</h1><p>rufus，微PE，官方</p><p>[TOC]</p><h2 id="一初次实践对象是老机子">一，初次实践对象是老机子</h2><p>​ 出于还想继续使用老机子，并且还想使用win10系统，我便对我的acer老机开始了炮制,虽然流程已经非常熟悉，实践起来还是遇到了一些障碍。</p><h2 id="二windows系统安装方法">二，windows系统安装方法</h2><ul><li>在本机直接进行升级安装</li><li>在微软官网下载ISO进行本机安装或进行U启制作</li><li>用 微PE等U启制作工具 制作U启（或者制作移动硬盘启动盘）</li></ul><h2 id="三装机步骤">三，装机步骤</h2><ol type="1"><li>采用PE装机方式，使用微PE（老毛桃亦可）制作U启盘 //此前应对U盘内文件进行备份，避免其中文件因格式化处理而丢失</li><li>从MSDN官网下载对应的系统镜像 或 从Microsoft官网下载win10的ISO 到制作完成的U启盘中，整理其中的文件，以免文件发生错乱 //PE操作系统的文件夹可能会隐藏，但使用时会显示出来。</li><li>将笔记本关机，将U启盘插入对应接口，在开机的过程按住机型所对应的BIOS界面切入键，在boot选项中将开机启动盘设置为U启盘，接着退出BIOS等待笔记本重启，接着便会进入PE预设置界面 ``</li><li>在PE界面中，有分区软件可以进行分区预设（新系统可以将分区卷类型设定为GUID，旧系统为RAM）;接着根据步骤：系统镜像→右键配置→在新弹出的界面点击setup，我们之后将会系统安装界面，按步骤进行即可。 //一般会把系统镜像安装在磁盘分区C:</li><li>安装流程完成后，系统会自动重启；接着再次在系统开机时进入BIOS，在boot中设置启动盘为系统镜像所在磁盘（避免再次进入PE界面）;接着系统会自动重启，进入windows系统的基本设置流程，完成后便进入win10界面，安装完成。</li></ol><h2 id="四安装时障碍和注意到东西">四，安装时障碍和注意到东西</h2><ol type="1"><li>没选用适合系统的微PE（32位，64位）</li><li>没有选用适合机型的系统（老机子）//我选用的是win10的LTSC版本，极度精简版</li><li>没有在系统重启时在BIOS设置启动盘，导致无法进入PE或一直进入PE却无法进入win10的解百纳设置界面</li><li>U启盘会隐藏U盘一部分空间，导致看到的U盘容量比先前看到的少了很多</li><li>U盘应选择质量好的，并且减少对U盘和SSD磁盘的格式化处理，会影响两者的使用寿命（机械硬盘似乎没问题）</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>computer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cpp速记</title>
    <link href="/2022/04/16/Cpp%E9%80%9F%E8%AE%B0/"/>
    <url>/2022/04/16/Cpp%E9%80%9F%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="第一章-面向对象和面向过程">第一章 面向对象和面向过程</h2><h4 id="面向过程">面向过程</h4><p>核心思想：功能分解 方法：自顶向下 逐层分解 设计范型：程序=算法+数据结构</p><h4 id="面向对象">面向对象</h4><p>以类的形式将 数据及对数据的相应操作以 类 的形式封装 作为一个整体 以类的对象 作为程序的基本单位 通过向对象发送 消息 启动相关操作</p><p><strong>类的特征</strong>：（组成） 静态特征 数据成员 动态特性 成员函数</p><p>类与对象 抽象与具体 类型与变量</p><p>面向对象 基本概念</p><p><strong>特征</strong>：</p><p>以类与对象作为核心概念 围绕类的定义及其使用的中心展开</p><ul><li>封装（封装机制～访问属性</li><li>继承（提高代码重用性 组织、构造、重用类的重要手段</li><li>多态（一种行为有多种实现方式 意义在于用一个接口实现不同操作</li></ul><p>对类进行实例化的对象才有意义 采用 接口 间接操作数据成员</p><p><strong>C++面向对象特征的体现</strong></p><ul><li>支持封装性</li><li>支持继承性（单继承和多继承）</li><li>支持多态性（静态联编和动态联编）</li></ul><p>C++为C的超集</p><p><strong>Simula 67</strong>为面向对象语言 鼻祖</p><h2 id="第二章-c的改进与扩展">第二章 C++的改进与扩展</h2><h3 id="函数重载"><strong>函数重载</strong></h3><p>函数重载（只关注形参 相同函数名 返回值类型无关联</p><p>形参默认值（定义首部和原型声明只能给一处，构造函数只能在类定义内部给出）</p><p>默认参数值（从右到左；实际参数（从左到右</p><p><strong>输入输出控制流——I/O流</strong> 流：一个对象到另一个对象的流动 cin&gt;&gt;输入时提取符后面只能跟变量 空格会分割数据 cout&lt;&lt;表达式可以</p><p>bool类型 常量true false（1 0 <strong>命名空间</strong> 定义方式 使用方式有三种 P14 <strong>其他</strong> string类型的使用 域解析符：：（不能重载</p><h3 id="引用"><strong>引用</strong></h3><p><strong>定义方式</strong></p><p>用&amp; 不是取地址 而是声明引用</p><p>必须初始化 只能初始化一次</p><p>*<strong>注意:</strong></p><p>不能创建引用的引用～&amp;&amp;a</p><p>不能创建指针的引用～&amp;*p</p><p>不能创建引用的数组（无法创建由引用组成的集合，但可以创建数组的引用）</p><p>不能创建void类型引用</p><p>用途： 作函数的形参 （引用参数扩大了引用变量的作用域，方便改变实参变量的值） 作函数返回值</p><p><strong>传值方式：</strong></p><p>传值 传地址 引用传值 常引用传值</p><p><strong>值形式参数 指针形式参数 引用形式参数 常引用参数的区分</strong></p><p>常引用形式参数（const typename &amp;a 常引用（引用变量a不能改变））的实际参数只能是变量，效率更高，无需分配额外空间，在函数中不能修改；</p><p>值形式参数可是变量、常量、表达式</p><p><strong>引用作为函数返回值注意：</strong></p><p>引用返回函数可以作为左值调用（放在等号左边</p><p>return后面只能是变量，不能是常量或常量表达式或常引用（只有变量可以作为左值</p><p>return后面变量的内存空间本次函数调用结束之后应当仍然存在（不能是局部变量）</p><p>引用返回的一般是函数中的一个引用形式参数</p><h3 id="动态内存空间处理函数new和delete">动态内存空间处理函数：new和delete</h3><p>C和C++申请动态数组的比较（一维数组和二维数组）</p><p>C++中强制类型转换的两种方式 (type) express 和 type (express) delete+数组名（而不加[])会只释放第一个元素的内存空间</p><p><strong>tip</strong>：</p><p>申请的空间 按逆序释放可预防错误 记得访问地址符*和自增自减的优先级 ++- -</p><h3 id="异常处理">异常处理</h3><p><strong>目的：</strong></p><p>对可以预测的错误（与期望结果不同）进行测试和处理</p><p>好处：将异常交给上级处理可以减轻底层函数负担（底层函数的具体实现没问题，让上级函数处理结果异常即可）</p><p>一定程度上保证了程序的健壮性</p><p><strong>相关语句</strong>： throw</p><p>try-catch ： 两者的语句块必须一起出现在可能出现异常的上级函数，之间不能有其他语句。 无异常便跳过catch部分，throw出异常便会中断语句块的余下部分。</p><h2 id="第三章-类与对象">第三章 类与对象</h2><p>类是对某一类对象的抽象，对象是某一种类的实例</p><p>利用类可以实现对类的抽象、数据和操作的封装以及信息的隐藏</p><p>面向对象程序设计的首要任务是 <strong>类的设计</strong>，其次是<strong>通过对象来使用类</strong></p><h3 id="类">类</h3><p><strong>类的特征</strong>：（组成） 静态特征 数据成员 动态特性 成员函数</p><p><strong>类的定义格式</strong>（和结构体相似</p><p>tips：</p><p>类里面定义的变量都是局部变量</p><p>注意分号别少</p><p>访问控制修饰符（省略了就默认是 private）</p><div class="code-wrapper"><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class&#123;    public:    int a,d;    protected:    double b;    string f;    private:    float c;    &#x2F;&#x2F;成员函数类似定义格式    public:    void SetA(int);    int GetA();&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p><strong>定义类的对象</strong></p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">类名 对象名1，[对象2，……，对象n]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><p><strong>访问数据成员</strong></p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">对象名.成员<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><p>在类定义内部，成员之间可直接访问</p><p>在类的外部，只有public属性的成员，可以通过该格式直接访问（比如main函数）</p><p><strong>成员函数的两种实现：</strong></p><p>一般将成员函数定义为公有成员</p><p>可以在类外实现 和 类内实现</p><p>类内实现自动识别为 内联函数 ；如需类外实现内联函数，则在类定义中的相应函数首部 增加关键字 <strong>inline</strong></p><p>内联函数减少函数调用的开发，一般最适用于那些非常短的简单函数，且不会显著增加可执行模块的大小</p><h3 id="访问属性">*访问属性</h3><p>关键字：public，private（只能被该类成员函数访问），protected（只允许该类及其派生类成员函数访问）</p><p>（缺省时默认时私有private）</p><p>区分三种属性的作用</p><h3 id="this指针">this指针</h3><p>每一个成员，1每个成员函数都有一个特殊的隐含指针，即this指针，用以存放当前对象的地址</p><p>对象调用成员函数——&gt;对象内存中地址传递给this指针——&gt;调用用成员函数，通过this指针调用实例对象值——&gt;返回值</p><p><strong>内存空间的分配是从高地址开始的</strong></p><h3 id="构造函数和析构函数">构造函数和析构函数</h3><p>这两种特殊函数，由系统自动调用</p><h4 id="构造函数">构造函数：</h4><ul><li>函数名与类名相同，以类名为函数名则一定为类的构造函数</li><li>没有返回值类型（给了会报错）、</li><li>一定要是public属性（否则会报错）</li><li>可重载的，要避免出现二义性</li><li>没有定义系统会自动生成系统默认无参构造函数，自定义了任意一种构造，则系统不会再生成</li></ul><p><strong>tips</strong>：系统默认无参构造函数只会创建对象，分配空间，不初始化数据成员</p><h4 id="构造函数的默认参数">构造函数的默认参数</h4><p>再定义类的构造函数时，可以指定形参默认值，但必须在 类定义的内部 给出</p><p>即类内只给出原型，而在类外实现时，默认形参也应该放在原型中</p><p>带默认参数的构造函数比较安全</p><h4 id="初始化列表">初始化列表</h4><p>某些数据成员初始化的唯一方法：</p><ul><li>需要初始化的数据成员是对象的情况(这里包含了继承情况下，通过显示调用父类的构造函数对父类数据成员进行初始化)；</li><li>需要初始化const修饰的类成员或初始化引用成员数据；</li><li>子类只能用列表初始化父类的私有成员；</li></ul><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">class Test&#123;private:int a;&#125;;class Test2:public Test&#123;public:Test2:Tset(2)&#123;&#x2F;&#x2F;Test(2);&#x2F;&#x2F;不能在内部调用，报错&#125;;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h4 id="复制构造函数">复制构造函数</h4><p>不自定义会自动生成</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">类名(const 类名 对象名);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><p>系统调用复制构造函数的三种情况：</p><ol type="1"><li>明确表示由一个一定义的对象初始化一个新对象</li><li>函数形参为一个对象（如果时引用或者指针对象的形参，则不会调用</li><li>对象作为返回值</li></ol><h4 id="析构函数">析构函数</h4><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">~类名( );<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><p><strong>注意：</strong></p><ul><li>不能重载</li><li>没有形参</li><li>每个类只能有一个</li></ul><p><strong>调用情况：</strong></p><ul><li>对象生命期结束时系统自动自动调用</li><li>delete释放用new申请的内存，也会自动调用</li></ul><h4 id="规则析构函数的调用顺序永远和构造函数的相反">规则：析构函数的调用顺序永远和构造函数的相反</h4><h3 id="深复制和浅复制">深复制和浅复制</h3><p>浅复制容易产生指针悬挂的问题</p><p>在复制构造函数换和对象赋值运算中会存在该问题</p>]]></content>
    
    
    
    <tags>
      
      <tag>learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>物理实验Note</title>
    <link href="/2022/04/15/%E7%89%A9%E7%90%86%E5%AE%9E%E9%AA%8CNote/"/>
    <url>/2022/04/15/%E7%89%A9%E7%90%86%E5%AE%9E%E9%AA%8CNote/</url>
    
    <content type="html"><![CDATA[<p>《物理实验教程》孙秀平</p><h2 id="测量误差与不确定度的评定">测量误差与不确定度的评定</h2><h2 id="一测量和单位">一、测量和单位</h2><p>物理量：数值+单位</p><p>（采用国际单位制）</p><h2 id="二测量的分类">二、测量的分类</h2><p>按测量过程：</p><ul><li>直接测量（将待测量与定标的测量仪器或量具比较，读出量值）</li><li>间接测量（通过相关物理量的直接测量，通过物理量之间一定的函数关系求出待测量的大小）</li></ul><h2 id="三有效数字">三、有效数字</h2><h3 id="有效数字的概念">有效数字的概念：</h3><ul><li>测量值的误差是不可避免，测量值包括<strong>精确数字和欠准数字</strong>两者总称为有效数字</li><li>大学物理实验，通常<strong>只取一位欠准数字</strong></li><li>有效数字反映了待测量的大小</li></ul><figure><img src="物理实验Note.assets/image-20220225204854832.png" alt="image-20220225204854832" /><figcaption aria-hidden="true">image-20220225204854832</figcaption></figure><h3 id="有效数字性质">有效数字性质：</h3><ul><li>有效数字位数与被测对象数值大小有关</li><li>有效数字位数与测量仪器精度有关</li></ul><figure><img src="物理实验Note.assets/image-20220225205109062-16501286710371.png" alt="image-20220225205109062" /><figcaption aria-hidden="true">image-20220225205109062</figcaption></figure><p>（位数越多，越精确）</p><figure><img src="物理实验Note.assets/image-20220225205214278-16501286710383.png" alt="image-20220225205214278" /><figcaption aria-hidden="true">image-20220225205214278</figcaption></figure><p>科学计数法不影响有效数字位数</p><h3 id="有效数字修约法则和运算处理">有效数字修约法则和运算处理：</h3><h5 id="修约规则">1、修约规则：</h5><p>有不确定度时，尾数修约规则：</p><figure><img src="物理实验Note.assets/image-20220225205342521-16501286710382.png" alt="image-20220225205342521" /><figcaption aria-hidden="true">image-20220225205342521</figcaption></figure><figure><img src="物理实验Note.assets/image-20220225205458888.png" alt="image-20220225205458888" /><figcaption aria-hidden="true">image-20220225205458888</figcaption></figure><h5 id="运算法则">2、运算法则：</h5><figure><img src="物理实验Note.assets/image-20220223102729656-16501286710384.png" alt="image-20220223102729656" /><figcaption aria-hidden="true">image-20220223102729656</figcaption></figure><figure><img src="物理实验Note.assets/image-20220223102817979-16501286710385.png" alt="image-20220223102817979" /><figcaption aria-hidden="true">image-20220223102817979</figcaption></figure><p>总的运算原则： <strong>抓两头</strong>，<strong>简化中间</strong></p><figure><img src="物理实验Note.assets/image-20220225210241942.png" alt="image-20220225210241942" /><figcaption aria-hidden="true">image-20220225210241942</figcaption></figure><p><strong>仪器误差或最小分度决定测量值的有效数字位数</strong></p><h2 id="四误差与不确定度">四、误差与不确定度</h2><h3 id="误差与真值">误差与真值：</h3><figure><img src="物理实验Note.assets/image-20220225210604927.png" alt="image-20220225210604927" /><figcaption aria-hidden="true">image-20220225210604927</figcaption></figure><h3 id="误差分类"><strong>误差分类</strong></h3><p>按特征和表现：</p><ul><li>系统误差---&gt;确定性</li><li>随机误差---&gt;随机性</li><li>粗差 ---&gt;可剔除</li></ul><h3 id="不确定度">不确定度</h3><p><strong>不确定度</strong>——测量结果正确程度的衡量标准，表示测量值可能变动的范围</p><p>分类：</p><ul><li>直接测量量不确定度：分A类和B类</li><li>间接测量量不确定度：有换算公式计算而得</li></ul><p><strong>（不确定度与误差是不同的量）</strong></p><h4 id="a.直接测量量不确定度的计算分析"><strong>A.直接测量量不确定度的计算分析：</strong></h4><figure><img src="物理实验Note.assets/image-20220225211225648.png" alt="image-20220225211225648" /><figcaption aria-hidden="true">image-20220225211225648</figcaption></figure><figure><img src="物理实验Note.assets/image-20220225211338754.png" alt="image-20220225211338754" /><figcaption aria-hidden="true">image-20220225211338754</figcaption></figure><p>例子：</p><figure><img src="物理实验Note.assets/image-20220225211427208.png" alt="image-20220225211427208" /><figcaption aria-hidden="true">image-20220225211427208</figcaption></figure><figure><img src="物理实验Note.assets/image-20220225211556251.png" alt="image-20220225211556251" /><figcaption aria-hidden="true">image-20220225211556251</figcaption></figure><p><strong>注意上图的不确定度的估计原则</strong></p><p>物理量的测量可分为 <strong>单次测量</strong> 和 <strong>多次测量</strong>：</p><h4 id="一单次测量">一、单次测量</h4><figure><img src="物理实验Note.assets/image-20220225211824739.png" alt="image-20220225211824739" /><figcaption aria-hidden="true">image-20220225211824739</figcaption></figure><p>不确定度只有B类，A类为0（只测量了一次）记得要修约和对齐</p><p>例子：</p><figure><img src="物理实验Note.assets/image-20220225212127865.png" alt="image-20220225212127865" /><figcaption aria-hidden="true">image-20220225212127865</figcaption></figure><h4 id="二多次重复测量">二、多次重复测量</h4><figure><img src="物理实验Note.assets/image-20220225212325914.png" alt="image-20220225212325914" /><figcaption aria-hidden="true">image-20220225212325914</figcaption></figure><p>(A和B类都有)</p><p>例子：</p><figure><img src="物理实验Note.assets/image-20220223110129867.png" alt="image-20220223110129867" /><figcaption aria-hidden="true">image-20220223110129867</figcaption></figure><figure><img src="物理实验Note.assets/image-20220225212629988.png" alt="image-20220225212629988" /><figcaption aria-hidden="true">image-20220225212629988</figcaption></figure><h4 id="三相对不确定度和百分差">三、相对不确定度和百分差</h4><figure><img src="物理实验Note.assets/image-20220223110449489.png" alt="image-20220223110449489" /><figcaption aria-hidden="true">image-20220223110449489</figcaption></figure><p><strong>所有的不确定修约规则都是相同的</strong></p><p>例子：</p><figure><img src="物理实验Note.assets/image-20220225213424038.png" alt="image-20220225213424038" /><figcaption aria-hidden="true">image-20220225213424038</figcaption></figure><h4 id="b.间接测量量不确定度的结果表示与计算分析">B.<strong>间接测量量不确定度的结果表示与计算分析:</strong></h4><figure><img src="物理实验Note.assets/image-20220225213713878.png" alt="image-20220225213713878" /><figcaption aria-hidden="true">image-20220225213713878</figcaption></figure><figure><img src="物理实验Note.assets/image-20220225213908662.png" alt="image-20220225213908662" /><figcaption aria-hidden="true">image-20220225213908662</figcaption></figure><p>(注意第二条公式)</p><figure><img src="物理实验Note.assets/image-20220225213951499.png" alt="image-20220225213951499" /><figcaption aria-hidden="true">image-20220225213951499</figcaption></figure><h2 id="五数据的基本处理方法">五、数据的基本处理方法</h2><p><strong>数据处理方法</strong></p><ul><li>列表法</li><li>作图法 （图要简明美观）（图解法，取图画上显示较远的两点）</li><li>逐差法(自变量之间等间距变化的数据）（最小二乘法）</li></ul><figure><img src="物理实验Note.assets/image-20220223113821757.png" alt="image-20220223113821757" /><figcaption aria-hidden="true">image-20220223113821757</figcaption></figure>]]></content>
    
    
    
    <tags>
      
      <tag>learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/04/13/hello-world/"/>
    <url>/2022/04/13/hello-world/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
