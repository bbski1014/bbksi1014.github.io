<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Cpp速记</title>
    <link href="/2022/04/16/Cpp%E9%80%9F%E8%AE%B0/"/>
    <url>/2022/04/16/Cpp%E9%80%9F%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="第一章-面向对象和面向过程"><a href="#第一章-面向对象和面向过程" class="headerlink" title="第一章 面向对象和面向过程"></a>第一章 面向对象和面向过程</h2><h4 id="面向过程"><a href="#面向过程" class="headerlink" title="面向过程"></a>面向过程</h4><p>核心思想：功能分解<br>方法：自顶向下 逐层分解<br>设计范型：程序&#x3D;算法+数据结构</p><h4 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h4><p>以类的形式将 数据及对数据的相应操作以 类 的形式封装 作为一个整体<br>以类的对象 作为程序的基本单位<br>通过向对象发送 消息 启动相关操作</p><p><strong>类的特征</strong>：（组成）<br>静态特征 数据成员<br>动态特性 成员函数</p><p>类与对象 抽象与具体 类型与变量</p><p>面向对象 基本概念</p><p><strong>特征</strong>：</p><p>以类与对象作为核心概念 围绕类的定义及其使用的中心展开</p><ul><li>封装（封装机制～访问属性</li><li>继承（提高代码重用性 组织、构造、重用类的重要手段</li><li>多态（一种行为有多种实现方式 意义在于用一个接口实现不同操作</li></ul><p>对类进行实例化的对象才有意义<br>采用 接口 间接操作数据成员</p><p><strong>C++面向对象特征的体现</strong></p><ul><li>支持封装性 </li><li>支持继承性（单继承和多继承）</li><li>支持多态性（静态联编和动态联编）</li></ul><p>C++为C的超集</p><p><strong>Simula 67</strong>为面向对象语言 鼻祖</p><h2 id="第二章-C-的改进与扩展"><a href="#第二章-C-的改进与扩展" class="headerlink" title="第二章 C++的改进与扩展"></a>第二章 C++的改进与扩展</h2><h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a><strong>函数重载</strong></h3><p>函数重载（只关注形参 相同函数名 返回值类型无关联</p><p>形参默认值（定义首部和原型声明只能给一处，构造函数只能在类定义内部给出）</p><p>默认参数值（从右到左；实际参数（从左到右</p><p><strong>输入输出控制流——I&#x2F;O流</strong><br>流：一个对象到另一个对象的流动<br>cin&gt;&gt;输入时提取符后面只能跟变量 空格会分割数据<br>cout&lt;&lt;表达式可以</p><p>bool类型 常量true false（1 0<br><strong>命名空间</strong><br>定义方式<br>使用方式有三种 P14<br><strong>其他</strong><br>string类型的使用<br>域解析符：：（不能重载</p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a><strong>引用</strong></h3><p><strong>定义方式</strong> </p><p>用&amp; 不是取地址 而是声明引用</p><p>必须初始化 只能初始化一次</p><p>*<strong>注意:</strong></p><p>不能创建引用的引用～&amp;&amp;a</p><p>不能创建指针的引用～&amp;*p</p><p>不能创建引用的数组（无法创建由引用组成的集合，但可以创建数组的引用）</p><p>不能创建void类型引用</p><p>用途：<br>作函数的形参 （引用参数扩大了引用变量的作用域，方便改变实参变量的值）<br>作函数返回值 </p><p><strong>传值方式：</strong></p><p>传值 传地址 引用传值 常引用传值</p><p><strong>值形式参数 指针形式参数 引用形式参数 常引用参数的区分</strong> </p><p>常引用形式参数（const typename &amp;a 常引用（引用变量a不能改变））的实际参数只能是变量，效率更高，无需分配额外空间，在函数中不能修改；</p><p>值形式参数可是变量、常量、表达式</p><p><strong>引用作为函数返回值注意：</strong></p><p>引用返回函数可以作为左值调用（放在等号左边</p><p>return后面只能是变量，不能是常量或常量表达式或常引用（只有变量可以作为左值</p><p>return后面变量的内存空间本次函数调用结束之后应当仍然存在（不能是局部变量）</p><p>引用返回的一般是函数中的一个引用形式参数</p><h3 id="动态内存空间处理函数：new和delete"><a href="#动态内存空间处理函数：new和delete" class="headerlink" title="动态内存空间处理函数：new和delete"></a>动态内存空间处理函数：new和delete</h3><p>C和C++申请动态数组的比较（一维数组和二维数组）</p><p>C++中强制类型转换的两种方式 (type) express 和 type (express)<br>delete+数组名（而不加[])会只释放第一个元素的内存空间</p><p><strong>tip</strong>：</p><p>申请的空间 按逆序释放可预防错误<br>记得访问地址符*和自增自减的优先级<br>++- -</p><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p><strong>目的：</strong></p><p>对可以预测的错误（与期望结果不同）进行测试和处理</p><p>好处：将异常交给上级处理可以减轻底层函数负担（底层函数的具体实现没问题，让上级函数处理结果异常即可）</p><p>一定程度上保证了程序的健壮性</p><p><strong>相关语句</strong>：<br>throw</p><p>try-catch ：<br>两者的语句块必须一起出现在可能出现异常的上级函数，之间不能有其他语句。<br>无异常便跳过catch部分，throw出异常便会中断语句块的余下部分。</p><h2 id="第三章-类与对象"><a href="#第三章-类与对象" class="headerlink" title="第三章 类与对象"></a>第三章 类与对象</h2><p>类是对某一类对象的抽象，对象是某一种类的实例</p><p>利用类可以实现对类的抽象、数据和操作的封装以及信息的隐藏</p><p>面向对象程序设计的首要任务是 <strong>类的设计</strong>，其次是<strong>通过对象来使用类</strong></p><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p><strong>类的特征</strong>：（组成）<br>静态特征 数据成员<br>动态特性 成员函数</p><p><strong>类的定义格式</strong>（和结构体相似</p><p>tips：</p><p>类里面定义的变量都是局部变量</p><p>注意分号别少</p><p>访问控制修饰符（省略了就默认是 private）</p><div class="code-wrapper"><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class&#123;    public:    int a,d;    protected:    double b;    string f;    private:    float c;    &#x2F;&#x2F;成员函数类似定义格式    public:    void SetA(int);    int GetA();&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p><strong>定义类的对象</strong></p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">类名 对象名1，[对象2，……，对象n]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><p><strong>访问数据成员</strong></p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">对象名.成员<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><p>在类定义内部，成员之间可直接访问</p><p>在类的外部，只有public属性的成员，可以通过该格式直接访问（比如main函数）</p><p><strong>成员函数的两种实现：</strong></p><p>一般将成员函数定义为公有成员</p><p>可以在类外实现 和 类内实现</p><p>类内实现自动识别为 内联函数 ；如需类外实现内联函数，则在类定义中的相应函数首部 增加关键字 <strong>inline</strong></p><p>内联函数减少函数调用的开发，一般最适用于那些非常短的简单函数，且不会显著增加可执行模块的大小</p><h3 id="访问属性"><a href="#访问属性" class="headerlink" title="*访问属性"></a>*访问属性</h3><p>关键字：public，private（只能被该类成员函数访问），protected（只允许该类及其派生类成员函数访问）</p><p>（缺省时默认时私有private）</p><p>区分三种属性的作用</p><h3 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h3><p>每一个成员，1每个成员函数都有一个特殊的隐含指针，即this指针，用以存放当前对象的地址</p><p>对象调用成员函数——&gt;对象内存中地址传递给this指针——&gt;调用用成员函数，通过this指针调用实例对象值——&gt;返回值</p><p><strong>内存空间的分配是从高地址开始的</strong></p><h3 id="构造函数和析构函数"><a href="#构造函数和析构函数" class="headerlink" title="构造函数和析构函数"></a>构造函数和析构函数</h3><p>这两种特殊函数，由系统自动调用</p><h4 id="构造函数："><a href="#构造函数：" class="headerlink" title="构造函数："></a>构造函数：</h4><ul><li>函数名与类名相同，以类名为函数名则一定为类的构造函数</li><li>没有返回值类型（给了会报错）、</li><li>一定要是public属性（否则会报错）</li><li>可重载的，要避免出现二义性</li><li>没有定义系统会自动生成系统默认无参构造函数，自定义了任意一种构造，则系统不会再生成</li></ul><p><strong>tips</strong>：系统默认无参构造函数只会创建对象，分配空间，不初始化数据成员</p><h4 id="构造函数的默认参数"><a href="#构造函数的默认参数" class="headerlink" title="构造函数的默认参数"></a>构造函数的默认参数</h4><p>再定义类的构造函数时，可以指定形参默认值，但必须在 类定义的内部 给出</p><p>即类内只给出原型，而在类外实现时，默认形参也应该放在原型中</p><p>带默认参数的构造函数比较安全</p><h4 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h4><p>某些数据成员初始化的唯一方法：</p><ul><li>需要初始化的数据成员是对象的情况(这里包含了继承情况下，通过显示调用父类的构造函数对父类数据成员进行初始化)； </li><li>需要初始化const修饰的类成员或初始化引用成员数据；</li><li>子类只能用列表初始化父类的私有成员；</li></ul><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">class Test&#123;private:int a;&#125;;class Test2:public Test&#123;public:Test2:Tset(2)&#123;&#x2F;&#x2F;Test(2);&#x2F;&#x2F;不能在内部调用，报错&#125;;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h4 id="复制构造函数"><a href="#复制构造函数" class="headerlink" title="复制构造函数"></a>复制构造函数</h4><p>不自定义会自动生成</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">类名(const 类名 对象名);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><p>系统调用复制构造函数的三种情况：</p><ol><li>明确表示由一个一定义的对象初始化一个新对象</li><li>函数形参为一个对象（如果时引用或者指针对象的形参，则不会调用</li><li>对象作为返回值</li></ol><h4 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h4><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">~类名( );<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><p><strong>注意：</strong></p><ul><li>不能重载</li><li>没有形参</li><li>每个类只能有一个</li></ul><p><strong>调用情况：</strong></p><ul><li>对象生命期结束时系统自动自动调用</li><li>delete释放用new申请的内存，也会自动调用</li></ul><h4 id="规则：析构函数的调用顺序永远和构造函数的相反"><a href="#规则：析构函数的调用顺序永远和构造函数的相反" class="headerlink" title="规则：析构函数的调用顺序永远和构造函数的相反"></a>规则：析构函数的调用顺序永远和构造函数的相反</h4><h3 id="深复制和浅复制"><a href="#深复制和浅复制" class="headerlink" title="深复制和浅复制"></a>深复制和浅复制</h3><p>浅复制容易产生指针悬挂的问题</p><p>在复制构造函数换和对象赋值运算中会存在该问题</p>]]></content>
    
    
    
    <tags>
      
      <tag>learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>物理实验Note</title>
    <link href="/2022/04/15/%E7%89%A9%E7%90%86%E5%AE%9E%E9%AA%8CNote/"/>
    <url>/2022/04/15/%E7%89%A9%E7%90%86%E5%AE%9E%E9%AA%8CNote/</url>
    
    <content type="html"><![CDATA[<p><img src="D:\Myblog\bbksi1014.github.io\Blog\source_posts\物理实验Note\image-20220223100528364.png" alt="image-20220223100528364"></p><p>《物理实验教程》孙秀平</p><h2 id="测量误差与不确定度的评定"><a href="#测量误差与不确定度的评定" class="headerlink" title="测量误差与不确定度的评定"></a>测量误差与不确定度的评定</h2><h2 id="一、测量和单位"><a href="#一、测量和单位" class="headerlink" title="一、测量和单位"></a>一、测量和单位</h2><p>物理量：数值+单位</p><p>（采用国际单位制）</p><h2 id="二、测量的分类"><a href="#二、测量的分类" class="headerlink" title="二、测量的分类"></a>二、测量的分类</h2><p>按测量过程：</p><ul><li>直接测量（将待测量与定标的测量仪器或量具比较，读出量值）</li><li>间接测量（通过相关物理量的直接测量，通过物理量之间一定的函数关系求出待测量的大小）</li></ul><h2 id="三、有效数字"><a href="#三、有效数字" class="headerlink" title="三、有效数字"></a>三、有效数字</h2><h3 id="有效数字的概念："><a href="#有效数字的概念：" class="headerlink" title="有效数字的概念："></a>有效数字的概念：</h3><ul><li>测量值的误差是不可避免，测量值包括<strong>精确数字和欠准数字</strong>两者总称为有效数字</li><li>大学物理实验，通常<strong>只取一位欠准数字</strong></li><li>有效数字反映了待测量的大小</li></ul><h3 id="有效数字性质："><a href="#有效数字性质：" class="headerlink" title="有效数字性质："></a>有效数字性质：</h3><ul><li>有效数字位数与被测对象数值大小有关</li><li>有效数字位数与测量仪器精度有关</li></ul><p><img src="D:\Myblog\bbksi1014.github.io\Blog\source_posts\物理实验Note\image-20220225205109062.png" alt="image-20220225205109062"></p><p>（位数越多，越精确）</p><p><img src="D:\Myblog\bbksi1014.github.io\Blog\source_posts\物理实验Note\image-20220225205214278.png" alt="image-20220225205214278"></p><p>科学计数法不影响有效数字位数</p><h3 id="有效数字修约法则和运算处理："><a href="#有效数字修约法则和运算处理：" class="headerlink" title="有效数字修约法则和运算处理："></a>有效数字修约法则和运算处理：</h3><h5 id="1、修约规则："><a href="#1、修约规则：" class="headerlink" title="1、修约规则："></a>1、修约规则：</h5><p>有不确定度时，尾数修约规则：</p><p><img src="D:\Myblog\bbksi1014.github.io\Blog\source_posts\物理实验Note\image-20220225205342521.png" alt="image-20220225205342521"></p><p><img src="D:\Myblog\bbksi1014.github.io\Blog\source_posts\物理实验Note\image-20220225205458888.png" alt="image-20220225205458888"></p><h5 id="2、运算法则："><a href="#2、运算法则：" class="headerlink" title="2、运算法则："></a>2、运算法则：</h5><p><img src="D:\Myblog\bbksi1014.github.io\Blog\source_posts\物理实验Note\image-20220223102729656.png" alt="image-20220223102729656"></p><p><img src="D:\Myblog\bbksi1014.github.io\Blog\source_posts\物理实验Note\image-20220223102817979.png" alt="image-20220223102817979"></p><p>总的运算原则： <strong>抓两头</strong>，<strong>简化中间</strong></p><p><img src="D:\Myblog\bbksi1014.github.io\Blog\source_posts\物理实验Note\image-20220225210241942.png" alt="image-20220225210241942"></p><p><strong>仪器误差或最小分度决定测量值的有效数字位数</strong></p><h2 id="四、误差与不确定度"><a href="#四、误差与不确定度" class="headerlink" title="四、误差与不确定度"></a>四、误差与不确定度</h2><h3 id="误差与真值："><a href="#误差与真值：" class="headerlink" title="误差与真值："></a>误差与真值：</h3><p><img src="D:\Myblog\bbksi1014.github.io\Blog\source_posts\物理实验Note\image-20220225210604927.png" alt="image-20220225210604927"></p><h3 id="误差分类"><a href="#误差分类" class="headerlink" title="误差分类"></a><strong>误差分类</strong></h3><p>按特征和表现：</p><ul><li>系统误差—&gt;确定性</li><li>随机误差—&gt;随机性</li><li>粗差 —&gt;可剔除</li></ul><h3 id="不确定度"><a href="#不确定度" class="headerlink" title="不确定度"></a>不确定度</h3><p><strong>不确定度</strong>——测量结果正确程度的衡量标准，表示测量值可能变动的范围</p><p>分类：</p><ul><li>直接测量量不确定度：分A类和B类</li><li>间接测量量不确定度：有换算公式计算而得</li></ul><p><strong>（不确定度与误差是不同的量）</strong></p><h4 id="A-直接测量量不确定度的计算分析："><a href="#A-直接测量量不确定度的计算分析：" class="headerlink" title="A.直接测量量不确定度的计算分析："></a><strong>A.直接测量量不确定度的计算分析：</strong></h4><p><img src="D:\Myblog\bbksi1014.github.io\Blog\source_posts\物理实验Note\image-20220225211225648.png" alt="image-20220225211225648"></p><p><img src="D:\Myblog\bbksi1014.github.io\Blog\source_posts\物理实验Note\image-20220225211338754.png" alt="image-20220225211338754"></p><p>例子：</p><p><img src="D:\Myblog\bbksi1014.github.io\Blog\source_posts\物理实验Note\image-20220225211427208.png" alt="image-20220225211427208"></p><p><img src="D:\Myblog\bbksi1014.github.io\Blog\source_posts\物理实验Note\image-20220225211556251.png" alt="image-20220225211556251"></p><p><strong>注意上图的不确定度的估计原则</strong></p><p>物理量的测量可分为 <strong>单次测量</strong> 和 <strong>多次测量</strong>：</p><h4 id="一、单次测量"><a href="#一、单次测量" class="headerlink" title="一、单次测量"></a>一、单次测量</h4><p><img src="D:\Myblog\bbksi1014.github.io\Blog\source_posts\物理实验Note\image-20220225211824739.png" alt="image-20220225211824739"></p><p>不确定度只有B类，A类为0（只测量了一次）记得要修约和对齐</p><p>例子：</p><p><img src="D:\Myblog\bbksi1014.github.io\Blog\source_posts\物理实验Note\image-20220225212127865.png" alt="image-20220225212127865"></p><h4 id="二、多次重复测量"><a href="#二、多次重复测量" class="headerlink" title="二、多次重复测量"></a>二、多次重复测量</h4><p><img src="D:\Myblog\bbksi1014.github.io\Blog\source_posts\物理实验Note\image-20220225212325914.png" alt="image-20220225212325914"></p><p>(A和B类都有)</p><p>例子：</p><p><img src="D:\Myblog\bbksi1014.github.io\Blog\source_posts\物理实验Note\image-20220223110129867.png" alt="image-20220223110129867"></p><p><img src="D:\Myblog\bbksi1014.github.io\Blog\source_posts\物理实验Note\image-20220225212629988.png" alt="image-20220225212629988"></p><h4 id="三、相对不确定度和百分差"><a href="#三、相对不确定度和百分差" class="headerlink" title="三、相对不确定度和百分差"></a>三、相对不确定度和百分差</h4><p><img src="D:\Myblog\bbksi1014.github.io\Blog\source_posts\物理实验Note\image-20220223110449489.png" alt="image-20220223110449489"></p><p><strong>所有的不确定修约规则都是相同的</strong></p><p>例子：</p><p><img src="D:\Myblog\bbksi1014.github.io\Blog\source_posts\物理实验Note\image-20220225213424038.png" alt="image-20220225213424038"></p><h4 id="B-间接测量量不确定度的结果表示与计算分析"><a href="#B-间接测量量不确定度的结果表示与计算分析" class="headerlink" title="B.间接测量量不确定度的结果表示与计算分析:"></a>B.<strong>间接测量量不确定度的结果表示与计算分析:</strong></h4><p><img src="D:\Myblog\bbksi1014.github.io\Blog\source_posts\物理实验Note\image-20220225213713878.png" alt="image-20220225213713878"></p><p><img src="D:\Myblog\bbksi1014.github.io\Blog\source_posts\物理实验Note\image-20220225213908662.png" alt="image-20220225213908662"></p><p>(注意第二条公式)</p><p><img src="D:\Myblog\bbksi1014.github.io\Blog\source_posts\物理实验Note\image-20220225213951499.png" alt="image-20220225213951499"></p><h2 id="五、数据的基本处理方法"><a href="#五、数据的基本处理方法" class="headerlink" title="五、数据的基本处理方法"></a>五、数据的基本处理方法</h2><p><strong>数据处理方法</strong></p><ul><li>列表法 </li><li>作图法 （图要简明美观）（图解法，取图画上显示较远的两点）</li><li>逐差法(自变量之间等间距变化的数据）（最小二乘法）</li></ul><p><img src="D:\Myblog\bbksi1014.github.io\Blog\source_posts\物理实验Note\image-20220223113821757.png" alt="image-20220223113821757"></p>]]></content>
    
    
    
    <tags>
      
      <tag>learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/04/13/hello-world/"/>
    <url>/2022/04/13/hello-world/</url>
    
    <content type="html"><![CDATA[<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
