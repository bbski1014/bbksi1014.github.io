<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>极限</title>
    <link href="/2022/04/18/%E6%9E%81%E9%99%90/"/>
    <url>/2022/04/18/%E6%9E%81%E9%99%90/</url>
    
    <content type="html"><![CDATA[<h1 id="极限">极限</h1><h1 id="数列极限基础">数列极限（基础）</h1><h2 id="极限定义的理解">极限定义的理解</h2><p>极限的数学定义应该是精确地 可定义的</p><p>e--&gt;N不是函数关系;</p><p>我们研究的是无穷序列，数列有极限就是在一定的e精确度下，存在N,让n&gt;N的无限多项存在于极限a的邻域内（<strong>在无穷的层面中也就是数列的基本全部项在邻域内</strong>，也就是趋近于某个值）;</p><p>换个说法，数列有有限项在领域外，意味着存在N让n&gt;N时，数列全部位于邻域内;</p><p>注意，一定是n&gt;N时，数列所有的项在邻域，这样才是保证了无穷数列基本完全处于邻域内;<strong>而数列有无穷多项处于邻域内数列就有极限的说法是错误的</strong>，应该是<strong>足够后面的所有的项</strong>都处在某个邻域内，无穷多项有可能只是后面所有项的一部分项。</p><figure><img src="C:\Users\L\OneDrive\桌面\开学文件\Typora%20Note\极限.assets\image-20210922091516811.png" alt="image-20210922091516811" /><figcaption aria-hidden="true">image-20210922091516811</figcaption></figure><p>例子</p><figure><img src="C:\Users\L\OneDrive\桌面\开学文件\Typora%20Note\极限.assets\image-20210922091550549.png" alt="image-20210922091550549" /><figcaption aria-hidden="true">image-20210922091550549</figcaption></figure><h2 id="极限证明的基本思路">极限证明的基本思路</h2><p>从极限存在的假设出发，以极限的定义为基础，观察数列解析式的性质，在数值或者变化范围的观点上(放缩的思路)，构造e从而证明N的存在性，进而便证明了极限的存在。</p><h2 id="极限的静态定义和动态定义">极限的静态定义和动态定义</h2><p>静态定义：</p><figure><img src="D:/Myblog/bbksi1014.github.io/Blog/source/_posts/%E6%9E%81%E9%99%90.assets/v2-f21285f2f94f0d62ea0325ae53a05d7a_720w.jpg" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>动态定义：</p><p><img src="D:/Myblog/bbksi1014.github.io/Blog/source/_posts/%E6%9E%81%E9%99%90.assets/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202021-09-15%20105552.png" /></p><p>我们所学的极限定义是从e的静态层面(给定精确度)之后进行分析，这种定义可以让我们以（e，N）能够定量对数列极限的存在进行精确分析。</p><h2 id="收敛数列的性质">收敛数列的性质</h2><ul><li>唯一性（收敛数列极限唯一）</li><li>有界性（收敛必定有界，有界不一定收敛）</li><li>保号性（极限数列可以反映数列的符号，数列的符号也可以反映极限的符号）</li></ul><p>数列收敛等价于数列存在极限</p><p>数列的保号性的强结论推导</p><h2 id="收敛数列和其子列的关系">收敛数列和其子列的关系</h2><p>原数列数列收敛，则其任意子列也收敛，且极限相同;</p><p>存在子列发散，则其原数列也发散</p><p>（可用于判别数列发散）</p><h1 id="函数的极限数列极限在函数中推广">函数的极限（数列极限在函数中推广）</h1><p>函数中的无穷符号要注明正负，数列本身已经将无穷定义为正</p><p>从离散到连续</p><p>三角不等式</p><h2 id="函数极限和数列极限的定义的异同">函数极限和数列极限的定义的异同</h2><p>函数的有界性和保号性是局部的 <span class="math display">\[\mathring{U}(1,2)\]</span></p><h2 id="复合函数的极限运算法则理解">复合函数的极限运算法则理解</h2><figure><img src="C:\Users\L\OneDrive\桌面\开学文件\Typora%20Note\极限.assets\image-20210922085858832.png" alt="image-20210922085858832" /><figcaption aria-hidden="true">image-20210922085858832</figcaption></figure><figure><img src="C:\Users\L\OneDrive\桌面\开学文件\Typora%20Note\极限.assets\image-20210922090838949.png" alt="image-20210922090838949" /><figcaption aria-hidden="true">image-20210922090838949</figcaption></figure><p>对法则约束条件 <span class="math display">\[x\in\mathring{U}({x_0},{\epsilon_0}),g(x)≠u_0\]</span> 的解释:</p><p>​ 从极限的定义上来看，对于内函数 <span class="math display">\[u=g(x)\]</span></p><p>​ 来说，若 <span class="math display">\[x\rightarrow{x_0},limg(x)=u_0\]</span> ​ 那么 <span class="math display">\[x\in\mathring{U}({x_0},{\epsilon_0})，u≠g(x)\]</span> ​ <strong>这样才符合极限存在的定义</strong></p><p>详细来说，便是：<strong>不能忽略中间变量u=g(x)的变化</strong> <span class="math display">\[\begin{align}&amp;对于复合函数的极限运算法则:\\&amp; \lim_{x\rightarrow{x_0}}f[g(x_0)]=\lim_{x\rightarrow{u_0}}f(u)=A\\&amp;该法则让我们可以可以通过换元的方式求取复合函数的极限，而该法则是有约束条件的(详情见书)，\\&amp;该约束条件意味着要想应用这条法则，复合函数应满足x\rightarrow{x_0}时，u=g(x)\rightarrow{u_0}(这包含着\\&amp;逼近但不等于u_0的意思)当x\rightarrow{x_0}时，或者说x\in\mathring{U}({x_0},{\epsilon_0})时，内函数u=g(x)的取值&amp;变化可能是:\\  &amp;1,\lim_{x\rightarrow{x_0}}\\  &amp;2,存在x=x_0使得f(x)=u_0或f(x)恒等于某个值u_0\\&amp;u的变化会因为x的控制而发生改变，变得无法逼近目标u_0,因此我们需要观察x的变化取判断u的变化，\\&amp;再去判断f(u)的u受到x控制后是否还能向u_0逼近，若符合第一种情况则该法则可用，\\&amp;若符合第二种情况则该法则不适用\\&amp;因为u\rightarrow{u_0}时，外函数的极限与u_0的取值无关，存在\lim_{u\rightarrow{u_0}}f(u)≠f(u_0)或f(u_0)不存在的情况,\\&amp;忽视约束条件运用该法则有可能取到的是f(u_0)的值,而不是当x\rightarrow{x_0}时,f(g(x))的极限值，\\&amp;因为我们忽视了中间变量u的变化情况，u有可能并不是随着x的逼近,逼近于u_0,而是会恒等于u_0或者u=f(x)\\&amp;甚至u=g(x)不存在极限,这时我们会取不到f(u)的极限值;\\&amp;我们并不是单纯得代入某个值给u，而是要观察u随着x的逼近\\&amp;得到u的变化情况，如果u逼近于某个值，则f(u)便有机会取到某个极限值，但不一定是f(u)\end{align}\]</span></p><h2 id="极限求值的技巧">极限求值的技巧</h2><p>做之前先观察极限 最好能得出极限的大概值</p><ul><li><p>分子或分母的有理化</p><p><strong>常用公式:</strong> <span class="math display">\[\begin{align}x^{n}-1&amp;=(x-1)(x^{n-1}+x^{n-2}+\dots+x+1)\\x&amp;=(\sqrt[n]{x+1})^{n}-1=(\sqrt[n]{x+1}-1)((\sqrt[n]{x+1})^{n-1}-(\sqrt[n]{x+1})^{n-2}+\dots+(\sqrt[n]{x+1})+1)\end{align}\]</span> <strong>同时,n次方的差公式为</strong> <span class="math display">\[\begin{align}a^2-b^2&amp;=(a-b)(a+b)\\a^3-b^3&amp;=(a-b)(a^2+ab+b^2)\\a^{n}-b^{n}&amp;=(a-b)(a^{n-1}+a^{n-2}b+a^{n-3}n^{n-2}+\dots+a^{2}b^{n-3}+ab^{n-2}+b^{n-1})\end{align}\]</span></p></li><li><p>取分式</p></li><li><p>换元</p></li><li><p>无穷小和无穷大乘以有界函数的定理</p></li></ul><p><strong>注意</strong>：<strong>无穷小x有界函数依旧是无穷小</strong></p><p>​ <strong>无穷大x有界函数不一定是无穷大</strong></p><p>如： <span class="math display">\[x\sin{\frac{1}{x}}\]</span> 运用夹逼准则证明极限的存在的话 要根据我们对极限的猜测 去构造两条逼近边界</p><p><strong>极限求值不等式：</strong> <span class="math display">\[[x]&gt;x+1\\绝对值不等式：\\||a|-|b||&lt;=|a+-b|&lt;=|a|+|b|\]</span></p><h1 id="无穷小的比较">无穷小的比较</h1><p>无穷小的阶数k是用来描述无穷小趋近于0的变化快慢 要<strong>大于0</strong> <span class="math display">\[\alpha(x)^k\]</span> <strong>无穷小替换法则只能替换因式，加减式不能替换</strong></p><p><strong>从泰勒展开公式</strong> <span class="math display">\[f(x)=f(x_0)+\frac{f^{(1)}(x_0)}{1!}+\frac{f^{(2)}(x_0)}{2!}+\dots+\frac{f^{(n)}(x_0)}{n!}+R_n(x)\\佩亚诺余项：R_n(x)=o[(x-x_0)^n]\\拉格朗日余项：R_n(x)=f^{n+1}[x_0+\theta(x-x_0)]\frac{(x-x_0)^{n+1}}{(n+1)!}\]</span> <strong>我们可以得知，我们替换等价无穷小时（一般替换成x^n），</strong></p><p><strong>其实是取 被替换的f(x) 的粗略展开，也就是f(x)泰勒展开的第一项往后的一部分项</strong></p><figure><img src="D:/Myblog/bbksi1014.github.io/Blog/source/_posts/%E6%9E%81%E9%99%90.assets/v2-8d85d36c6b00dd2c97e9921c88e0398b_r.jpg" alt="preview" /><figcaption aria-hidden="true">preview</figcaption></figure><p><strong>当我们用加减时，有可能将一部分更高阶的无穷小给忽略掉，导致结果出错</strong></p><p><strong>但有时候加减也可以，在比较无穷小的阶数时，只要更低阶的无穷小没有因为加减而消去，则可以对加减式进行无穷小的替换；但是计算极限时会不能替换</strong></p><figure><img src="C:\Users\L\OneDrive\桌面\开学文件\Typora%20Note\极限.assets\image-20210926105256381.png" alt="image-20210926105256381" /><figcaption aria-hidden="true">image-20210926105256381</figcaption></figure>]]></content>
    
    
    
    <tags>
      
      <tag>learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二进制编码和计算机存储</title>
    <link href="/2022/04/17/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E7%A0%81%E5%92%8C%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%98%E5%82%A8/"/>
    <url>/2022/04/17/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E7%A0%81%E5%92%8C%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%98%E5%82%A8/</url>
    
    <content type="html"><![CDATA[<p>参考资料：计算机科学导论 汇编原理（王爽）</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;bbski&#x2F;bbski1014.github.io@latest<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><h1 id="关于二进制编码和存储知识">关于二进制编码和存储知识</h1><p>参考资料：计算机科学导论 汇编原理（王爽）</p><p>视频<a href="https://www.bilibili.com/video/BV1ni4y1G7B9?p=10">狂神说</a></p><h3 id="进制转换">1，进制转换</h3><h4 id="进制只是一种对数字的编码方式">进制只是一种对数字的编码方式</h4><p>​ 我们因为身边的客观事物（10根手指）对十进制数字编码更为熟悉，但数的概念是独立的，数的运算法则是完备的，而进制只是数的表达方式，所以每一种进制在数字的运算法则上完备的。</p><p>​ 数的任何进制表达都是有序的，就像十进制一样（数表），我们在计算时，有“查数“的思想，就像是在十进制运算中中，我们在运算时其实会调取熟记于心的九九加法表和九九乘法表（这些表记录了十进制个位基本运算）;<strong><em>要想对其他的进制套用十进制的运算模式</em></strong>，我们可以根据其他进制中，亦可以<strong><em>编制一个对应的”加乘表“</em></strong>，用<strong><em>”查数“</em></strong>的思想（或者说查表），即可对不同进制的数进行十进制算数模式的套用;其中减除的运算需要我们可以用加乘的逆运算思想进行匹配，从而得出结果。</p><p>​ 我们要注意我们要对不同进制的“个位数”进行预编码，例如十进制中我们有0-9，二进制中0和1，0-9不够用的我们可以用其他字符来代替，比如16进制我们可以用0-9以及A-F，<strong><em>也就是说只要我们愿意，我们也可以将十进制中的0-9化成其他的字符</em></strong>。</p><p>​ 我们现在用的比较多的进制位2,4,8,16（基数都是2的指数）</p><h4 id="进制的转换重点在于数字编码的位比如十进制的个十百">进制的转换重点在于数字编码的位（比如十进制的个，十，百）</h4><p><strong>a.十进制与其他进制数的转化</strong>（较常用）：</p><p>​ 任何数的进制都可以用<strong>“按权展开”</strong>的方式将不同进制的数转化为十进制（这个权是位权，十进制本身显然）</p><p>​ 十进制数转换为其他的进制可以<strong>对整数部分 除“数”取余</strong>，<strong>对小数部分 乘“数”取整</strong>，直至小数部分为0即可</p><p>（“数”是基数，进制），小数部分最后有可能无法取0，在目标进制中为无限小数。</p><p><strong>b.一种进制的有限小数部分 在另一种进制有可能会变成 无法精确表达的无限小数</strong></p><p>​ 某种进制中的小数在另一种进制中能被有限表达是有条件的————原进制中的小数部分能在目标进制中</p><p>​ 能按权展开，比如0.75（10）可以在二进制中按位权2展开位0.11（2）。</p><p>​ 显然这也导致了，在计算机中，十进制数小数部分在二进制中有可能会不能精确的表达出来;事实上，十进</p><p>​ 制小数基本不会在二进制中被表示成有限小数。</p><p><strong>c.常用的2,4,8（取三合一）,16（取四合一）进制相互之间的转化可以用“合位”的思想</strong></p><p>​ 通常我们会将较长二进制数转化为其他其他的2^n进制，表达更为简短</p><p>​ 八进制数和16进制的相互转化应该使用二进制作为转化中介,因为“合位”的前提在于，合位取的数能在目标进</p><p>​ 进制中能被个位编码表达，八和16进制是无法直接进行“合位”转换的。</p><p><strong>d.小数部分能否按权展开的确定</strong></p><p>​ 我们可以用将原进制转化为十进制，观察数的大小，再看这个小数能否以目标位权进行展开。</p><figure><img src="D:/Myblog/bbksi1014.github.io/Blog/source/_posts/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E7%A0%81%E5%92%8C%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%98%E5%82%A8.assets/20210514113026699-165013343878934.png" alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><h3 id="机器码的编码原码反码一补数补码二补数">2，机器码的编码：原码反码（一补数）补码（二补数）</h3><p><strong>参考资料：</strong></p><p><a href="https://www.cnblogs.com/zhangziqiu/archive/2011/03/30/ComputerCode.html">详解</a> <a href="https://zhuanlan.zhihu.com/p/99082236">较简易解释</a> <a href="https://www.jianshu.com/p/ffc97c4d2306">有关数据溢出</a></p><p><strong>编码法则：</strong></p><figure><img src="D:/Myblog/bbksi1014.github.io/Blog/source/_posts/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E7%A0%81%E5%92%8C%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%98%E5%82%A8.assets/image-20210916130538882-165013343879438.png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p><strong>正数不变，负数要变，符号位需保留。（首位为符号位，0为正，1为负）</strong></p><p><strong>补码为减法而生</strong>，我们为了方便，将机器码的首位设置为符号位，接着开始研究机器码的加减，发现过程中产生了一系列问题，最后用补码的方式解决了。</p><p><strong>负数原码&gt;&gt;反码&gt;&gt;补码的过程实则是：取负数十进制的数值的绝对值，急着按位取反，接着补1，从而得到-1（10）在计算机中的二进制表达</strong>（这个结论可以通过n-x=0的方式来判断）</p><p><strong>补码的生活实例证明是时钟。</strong></p><p><strong>整数型数据在计算机中，用补码表示。</strong></p><p>​ <img src="D:/Myblog/bbksi1014.github.io/Blog/source/_posts/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E7%A0%81%E5%92%8C%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%98%E5%82%A8.assets/201103302155504514-165013343878936.jpg" alt="clip_image001" /></p><figure><img src="D:/Myblog/bbksi1014.github.io/Blog/source/_posts/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E7%A0%81%E5%92%8C%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%98%E5%82%A8.assets/image-20210916135015023-165013343879440.png" alt="image-20210916135015023" /><figcaption aria-hidden="true">image-20210916135015023</figcaption></figure><p>此时, 表盘相当于每128个刻度转一轮. 所以用补码表示的运算结果最小值和最大值应该是[-128, 127]。</p><p>一个数的反码, 实际上是这个数对于一个膜的同余数. 而这个膜并不是我们的二进制, 而是所能表示的最大值! 这就和钟表一样, 转了一圈后总能找到在可表示范围内的一个正确的数值!</p><h3 id="位运算">3.位运算</h3><p><a href="https://www.runoob.com/w3cnote/bit-operation.html">位运算概述</a></p><p><a href="https://zhuanlan.zhihu.com/p/102277869">使用案例</a></p><p>合理使用位运算能 <strong>避免数据的溢出</strong></p><p>​ <strong>加快乘除法的运行速度</strong>（加减法与正常算法速度相当）</p><p>​ 这是因为位运算指令只占用CPU两个运行周期 而 乘除指令占了4个；</p><h2 id="计算机结构基础">2，计算机结构基础</h2><h3 id="计算机三大总线">1，计算机三大总线：</h3><p>CPU要想进行数据读写，达成读取内存地址和操作外设的目的，需要对系统进行信息的交互</p><p>交互的信息有：</p><ul><li>地址信息（存储单位的地址）</li><li>数据信息（器件的选择，读写命令）</li><li>控制信息（读写的数据）</li></ul><p>交互的途径（电信号的传播）：</p><ul><li>地址总线（决定了CPU寻址能力2^n）</li><li>数据总线（决定了CPU单次数据传输量）</li><li>控制总线（决定了CPU对系统其他部件的控制能力）</li></ul><h3 id="cpu读取内存数据的过程">2，CPU读取内存数据的过程</h3><p><strong>物理存储器的分类</strong></p><p>按读写性质可分为：</p><ul><li>随机存储器RAM //挥发性内存，带电读写，断电清空</li><li>只读存储器ROM //非挥发性内存 只读不写 断电内容不丢失</li></ul><p>按功能和连接可分为：</p><ul><li>随机存储器（供CPU使用的大部分数据程序）</li><li>装有BIOS的ROM（存储着供各种外部设备启动的程序）</li><li>接口卡上的RAM（需对大量暂时性数据进行存储，如显卡的显存）</li></ul><p><strong>内存存储空间</strong></p><p>物理存储器看似独立，其实都是与CPU总线相连，CPU通过控制总线对他们发出内存读写命令，所以，CPU把所有的存储器都当内存对待，看做一个有若干存储单元组成的逻辑存储器，这就是所谓的内存地址空间。</p><p><img src="D:/Myblog/bbksi1014.github.io/Blog/source/_posts/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E7%A0%81%E5%92%8C%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%98%E5%82%A8.assets/image-20210916222354918-165013343879439.png" /></p><p><img src="D:/Myblog/bbksi1014.github.io/Blog/source/_posts/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E7%A0%81%E5%92%8C%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%98%E5%82%A8.assets/image-20210916222437567-165013343879442.png" /></p><p><strong>CPU组成</strong></p><ul><li>运算器（信息处理）</li><li>控制器（控制各个器件）</li><li>寄存器（信息存储）</li></ul><p>（可能还有二级高速缓存）</p><p><strong>关于CPU位数</strong>：</p><p><img src="D:/Myblog/bbksi1014.github.io/Blog/source/_posts/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E7%A0%81%E5%92%8C%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%98%E5%82%A8.assets/image-20210916225129979-165013343879441.png" /></p><h2 id="计算机程序运行的虚拟内存">计算机程序运行的虚拟内存</h2>]]></content>
    
    
    
    <tags>
      
      <tag>learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>系统重装PE</title>
    <link href="/2022/04/16/%E7%B3%BB%E7%BB%9F%E9%87%8D%E8%A3%85PE/"/>
    <url>/2022/04/16/%E7%B3%BB%E7%BB%9F%E9%87%8D%E8%A3%85PE/</url>
    
    <content type="html"><![CDATA[<h1 id="重装系统初体验pe">重装系统初体验（PE）</h1><p>rufus，微PE，官方</p><p>[TOC]</p><h2 id="一初次实践对象是老机子">一，初次实践对象是老机子</h2><p>​ 出于还想继续使用老机子，并且还想使用win10系统，我便对我的acer老机开始了炮制,虽然流程已经非常熟悉，实践起来还是遇到了一些障碍。</p><h2 id="二windows系统安装方法">二，windows系统安装方法</h2><ul><li>在本机直接进行升级安装</li><li>在微软官网下载ISO进行本机安装或进行U启制作</li><li>用 微PE等U启制作工具 制作U启（或者制作移动硬盘启动盘）</li></ul><h2 id="三装机步骤">三，装机步骤</h2><ol type="1"><li>采用PE装机方式，使用微PE（老毛桃亦可）制作U启盘 //此前应对U盘内文件进行备份，避免其中文件因格式化处理而丢失</li><li>从MSDN官网下载对应的系统镜像 或 从Microsoft官网下载win10的ISO 到制作完成的U启盘中，整理其中的文件，以免文件发生错乱 //PE操作系统的文件夹可能会隐藏，但使用时会显示出来。</li><li>将笔记本关机，将U启盘插入对应接口，在开机的过程按住机型所对应的BIOS界面切入键，在boot选项中将开机启动盘设置为U启盘，接着退出BIOS等待笔记本重启，接着便会进入PE预设置界面 ``</li><li>在PE界面中，有分区软件可以进行分区预设（新系统可以将分区卷类型设定为GUID，旧系统为RAM）;接着根据步骤：系统镜像→右键配置→在新弹出的界面点击setup，我们之后将会系统安装界面，按步骤进行即可。 //一般会把系统镜像安装在磁盘分区C:</li><li>安装流程完成后，系统会自动重启；接着再次在系统开机时进入BIOS，在boot中设置启动盘为系统镜像所在磁盘（避免再次进入PE界面）;接着系统会自动重启，进入windows系统的基本设置流程，完成后便进入win10界面，安装完成。</li></ol><h2 id="四安装时障碍和注意到东西">四，安装时障碍和注意到东西</h2><ol type="1"><li>没选用适合系统的微PE（32位，64位）</li><li>没有选用适合机型的系统（老机子）//我选用的是win10的LTSC版本，极度精简版</li><li>没有在系统重启时在BIOS设置启动盘，导致无法进入PE或一直进入PE却无法进入win10的解百纳设置界面</li><li>U启盘会隐藏U盘一部分空间，导致看到的U盘容量比先前看到的少了很多</li><li>U盘应选择质量好的，并且减少对U盘和SSD磁盘的格式化处理，会影响两者的使用寿命（机械硬盘似乎没问题）</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>computer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cpp速记</title>
    <link href="/2022/04/16/Cpp%E9%80%9F%E8%AE%B0/"/>
    <url>/2022/04/16/Cpp%E9%80%9F%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="第一章-面向对象和面向过程">第一章 面向对象和面向过程</h2><h4 id="面向过程">面向过程</h4><p>核心思想：功能分解 方法：自顶向下 逐层分解 设计范型：程序=算法+数据结构</p><h4 id="面向对象">面向对象</h4><p>以类的形式将 数据及对数据的相应操作以 类 的形式封装 作为一个整体 以类的对象 作为程序的基本单位 通过向对象发送 消息 启动相关操作</p><p><strong>类的特征</strong>：（组成） 静态特征 数据成员 动态特性 成员函数</p><p>类与对象 抽象与具体 类型与变量</p><p>面向对象 基本概念</p><p><strong>特征</strong>：</p><p>以类与对象作为核心概念 围绕类的定义及其使用的中心展开</p><ul><li>封装（封装机制～访问属性</li><li>继承（提高代码重用性 组织、构造、重用类的重要手段</li><li>多态（一种行为有多种实现方式 意义在于用一个接口实现不同操作</li></ul><p>对类进行实例化的对象才有意义 采用 接口 间接操作数据成员</p><p><strong>C++面向对象特征的体现</strong></p><ul><li>支持封装性</li><li>支持继承性（单继承和多继承）</li><li>支持多态性（静态联编和动态联编）</li></ul><p>C++为C的超集</p><p><strong>Simula 67</strong>为面向对象语言 鼻祖</p><h2 id="第二章-c的改进与扩展">第二章 C++的改进与扩展</h2><h3 id="函数重载"><strong>函数重载</strong></h3><p>函数重载（只关注形参 相同函数名 返回值类型无关联</p><p>形参默认值（定义首部和原型声明只能给一处，构造函数只能在类定义内部给出）</p><p>默认参数值（从右到左；实际参数（从左到右</p><p><strong>输入输出控制流——I/O流</strong> 流：一个对象到另一个对象的流动 cin&gt;&gt;输入时提取符后面只能跟变量 空格会分割数据 cout&lt;&lt;表达式可以</p><p>bool类型 常量true false（1 0 <strong>命名空间</strong> 定义方式 使用方式有三种 P14 <strong>其他</strong> string类型的使用 域解析符：：（不能重载</p><h3 id="引用"><strong>引用</strong></h3><p><strong>定义方式</strong></p><p>用&amp; 不是取地址 而是声明引用</p><p>必须初始化 只能初始化一次</p><p>*<strong>注意:</strong></p><p>不能创建引用的引用～&amp;&amp;a</p><p>不能创建指针的引用～&amp;*p</p><p>不能创建引用的数组（无法创建由引用组成的集合，但可以创建数组的引用）</p><p>不能创建void类型引用</p><p>用途： 作函数的形参 （引用参数扩大了引用变量的作用域，方便改变实参变量的值） 作函数返回值</p><p><strong>传值方式：</strong></p><p>传值 传地址 引用传值 常引用传值</p><p><strong>值形式参数 指针形式参数 引用形式参数 常引用参数的区分</strong></p><p>常引用形式参数（const typename &amp;a 常引用（引用变量a不能改变））的实际参数只能是变量，效率更高，无需分配额外空间，在函数中不能修改；</p><p>值形式参数可是变量、常量、表达式</p><p><strong>引用作为函数返回值注意：</strong></p><p>引用返回函数可以作为左值调用（放在等号左边</p><p>return后面只能是变量，不能是常量或常量表达式或常引用（只有变量可以作为左值</p><p>return后面变量的内存空间本次函数调用结束之后应当仍然存在（不能是局部变量）</p><p>引用返回的一般是函数中的一个引用形式参数</p><h3 id="动态内存空间处理函数new和delete">动态内存空间处理函数：new和delete</h3><p>C和C++申请动态数组的比较（一维数组和二维数组）</p><p>C++中强制类型转换的两种方式 (type) express 和 type (express) delete+数组名（而不加[])会只释放第一个元素的内存空间</p><p><strong>tip</strong>：</p><p>申请的空间 按逆序释放可预防错误 记得访问地址符*和自增自减的优先级 ++- -</p><h3 id="异常处理">异常处理</h3><p><strong>目的：</strong></p><p>对可以预测的错误（与期望结果不同）进行测试和处理</p><p>好处：将异常交给上级处理可以减轻底层函数负担（底层函数的具体实现没问题，让上级函数处理结果异常即可）</p><p>一定程度上保证了程序的健壮性</p><p><strong>相关语句</strong>： throw</p><p>try-catch ： 两者的语句块必须一起出现在可能出现异常的上级函数，之间不能有其他语句。 无异常便跳过catch部分，throw出异常便会中断语句块的余下部分。</p><h2 id="第三章-类与对象">第三章 类与对象</h2><p>类是对某一类对象的抽象，对象是某一种类的实例</p><p>利用类可以实现对类的抽象、数据和操作的封装以及信息的隐藏</p><p>面向对象程序设计的首要任务是 <strong>类的设计</strong>，其次是<strong>通过对象来使用类</strong></p><h3 id="类">类</h3><p><strong>类的特征</strong>：（组成） 静态特征 数据成员 动态特性 成员函数</p><p><strong>类的定义格式</strong>（和结构体相似</p><p>tips：</p><p>类里面定义的变量都是局部变量</p><p>注意分号别少</p><p>访问控制修饰符（省略了就默认是 private）</p><div class="code-wrapper"><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class&#123;    public:    int a,d;    protected:    double b;    string f;    private:    float c;    &#x2F;&#x2F;成员函数类似定义格式    public:    void SetA(int);    int GetA();&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p><strong>定义类的对象</strong></p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">类名 对象名1，[对象2，……，对象n]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><p><strong>访问数据成员</strong></p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">对象名.成员<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><p>在类定义内部，成员之间可直接访问</p><p>在类的外部，只有public属性的成员，可以通过该格式直接访问（比如main函数）</p><p><strong>成员函数的两种实现：</strong></p><p>一般将成员函数定义为公有成员</p><p>可以在类外实现 和 类内实现</p><p>类内实现自动识别为 内联函数 ；如需类外实现内联函数，则在类定义中的相应函数首部 增加关键字 <strong>inline</strong></p><p>内联函数减少函数调用的开发，一般最适用于那些非常短的简单函数，且不会显著增加可执行模块的大小</p><h3 id="访问属性">*访问属性</h3><p>关键字：public，private（只能被该类成员函数访问），protected（只允许该类及其派生类成员函数访问）</p><p>（缺省时默认时私有private）</p><p>区分三种属性的作用</p><h3 id="this指针">this指针</h3><p>每一个成员，1每个成员函数都有一个特殊的隐含指针，即this指针，用以存放当前对象的地址</p><p>对象调用成员函数——&gt;对象内存中地址传递给this指针——&gt;调用用成员函数，通过this指针调用实例对象值——&gt;返回值</p><p><strong>内存空间的分配是从高地址开始的</strong></p><h3 id="构造函数和析构函数">构造函数和析构函数</h3><p>这两种特殊函数，由系统自动调用</p><h4 id="构造函数">构造函数：</h4><ul><li>函数名与类名相同，以类名为函数名则一定为类的构造函数</li><li>没有返回值类型（给了会报错）、</li><li>一定要是public属性（否则会报错）</li><li>可重载的，要避免出现二义性</li><li>没有定义系统会自动生成系统默认无参构造函数，自定义了任意一种构造，则系统不会再生成</li></ul><p><strong>tips</strong>：系统默认无参构造函数只会创建对象，分配空间，不初始化数据成员</p><h4 id="构造函数的默认参数">构造函数的默认参数</h4><p>再定义类的构造函数时，可以指定形参默认值，但必须在 类定义的内部 给出</p><p>即类内只给出原型，而在类外实现时，默认形参也应该放在原型中</p><p>带默认参数的构造函数比较安全</p><h4 id="初始化列表">初始化列表</h4><p>某些数据成员初始化的唯一方法：</p><ul><li>需要初始化的数据成员是对象的情况(这里包含了继承情况下，通过显示调用父类的构造函数对父类数据成员进行初始化)；</li><li>需要初始化const修饰的类成员或初始化引用成员数据；</li><li>子类只能用列表初始化父类的私有成员；</li></ul><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">class Test&#123;private:int a;&#125;;class Test2:public Test&#123;public:Test2:Tset(2)&#123;&#x2F;&#x2F;Test(2);&#x2F;&#x2F;不能在内部调用，报错&#125;;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h4 id="复制构造函数">复制构造函数</h4><p>不自定义会自动生成</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">类名(const 类名 对象名);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><p>系统调用复制构造函数的三种情况：</p><ol type="1"><li>明确表示由一个一定义的对象初始化一个新对象</li><li>函数形参为一个对象（如果时引用或者指针对象的形参，则不会调用</li><li>对象作为返回值</li></ol><h4 id="析构函数">析构函数</h4><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">~类名( );<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><p><strong>注意：</strong></p><ul><li>不能重载</li><li>没有形参</li><li>每个类只能有一个</li></ul><p><strong>调用情况：</strong></p><ul><li>对象生命期结束时系统自动自动调用</li><li>delete释放用new申请的内存，也会自动调用</li></ul><h4 id="规则析构函数的调用顺序永远和构造函数的相反">规则：析构函数的调用顺序永远和构造函数的相反</h4><h3 id="深复制和浅复制">深复制和浅复制</h3><p>浅复制容易产生指针悬挂的问题</p><p>在复制构造函数换和对象赋值运算中会存在该问题</p>]]></content>
    
    
    
    <tags>
      
      <tag>learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>物理实验Note</title>
    <link href="/2022/04/15/%E7%89%A9%E7%90%86%E5%AE%9E%E9%AA%8CNote/"/>
    <url>/2022/04/15/%E7%89%A9%E7%90%86%E5%AE%9E%E9%AA%8CNote/</url>
    
    <content type="html"><![CDATA[<p>《物理实验教程》孙秀平</p><h2 id="测量误差与不确定度的评定">测量误差与不确定度的评定</h2><h2 id="一测量和单位">一、测量和单位</h2><p>物理量：数值+单位</p><p>（采用国际单位制）</p><h2 id="二测量的分类">二、测量的分类</h2><p>按测量过程：</p><ul><li>直接测量（将待测量与定标的测量仪器或量具比较，读出量值）</li><li>间接测量（通过相关物理量的直接测量，通过物理量之间一定的函数关系求出待测量的大小）</li></ul><h2 id="三有效数字">三、有效数字</h2><h3 id="有效数字的概念">有效数字的概念：</h3><ul><li>测量值的误差是不可避免，测量值包括<strong>精确数字和欠准数字</strong>两者总称为有效数字</li><li>大学物理实验，通常<strong>只取一位欠准数字</strong></li><li>有效数字反映了待测量的大小</li></ul><figure><img src="物理实验Note.assets/image-20220225204854832.png" alt="image-20220225204854832" /><figcaption aria-hidden="true">image-20220225204854832</figcaption></figure><h3 id="有效数字性质">有效数字性质：</h3><ul><li>有效数字位数与被测对象数值大小有关</li><li>有效数字位数与测量仪器精度有关</li></ul><figure><img src="物理实验Note.assets/image-20220225205109062-16501286710371.png" alt="image-20220225205109062" /><figcaption aria-hidden="true">image-20220225205109062</figcaption></figure><p>（位数越多，越精确）</p><figure><img src="物理实验Note.assets/image-20220225205214278-16501286710383.png" alt="image-20220225205214278" /><figcaption aria-hidden="true">image-20220225205214278</figcaption></figure><p>科学计数法不影响有效数字位数</p><h3 id="有效数字修约法则和运算处理">有效数字修约法则和运算处理：</h3><h5 id="修约规则">1、修约规则：</h5><p>有不确定度时，尾数修约规则：</p><figure><img src="物理实验Note.assets/image-20220225205342521-16501286710382.png" alt="image-20220225205342521" /><figcaption aria-hidden="true">image-20220225205342521</figcaption></figure><figure><img src="物理实验Note.assets/image-20220225205458888.png" alt="image-20220225205458888" /><figcaption aria-hidden="true">image-20220225205458888</figcaption></figure><h5 id="运算法则">2、运算法则：</h5><figure><img src="物理实验Note.assets/image-20220223102729656-16501286710384.png" alt="image-20220223102729656" /><figcaption aria-hidden="true">image-20220223102729656</figcaption></figure><figure><img src="物理实验Note.assets/image-20220223102817979-16501286710385.png" alt="image-20220223102817979" /><figcaption aria-hidden="true">image-20220223102817979</figcaption></figure><p>总的运算原则： <strong>抓两头</strong>，<strong>简化中间</strong></p><figure><img src="物理实验Note.assets/image-20220225210241942.png" alt="image-20220225210241942" /><figcaption aria-hidden="true">image-20220225210241942</figcaption></figure><p><strong>仪器误差或最小分度决定测量值的有效数字位数</strong></p><h2 id="四误差与不确定度">四、误差与不确定度</h2><h3 id="误差与真值">误差与真值：</h3><figure><img src="物理实验Note.assets/image-20220225210604927.png" alt="image-20220225210604927" /><figcaption aria-hidden="true">image-20220225210604927</figcaption></figure><h3 id="误差分类"><strong>误差分类</strong></h3><p>按特征和表现：</p><ul><li>系统误差---&gt;确定性</li><li>随机误差---&gt;随机性</li><li>粗差 ---&gt;可剔除</li></ul><h3 id="不确定度">不确定度</h3><p><strong>不确定度</strong>——测量结果正确程度的衡量标准，表示测量值可能变动的范围</p><p>分类：</p><ul><li>直接测量量不确定度：分A类和B类</li><li>间接测量量不确定度：有换算公式计算而得</li></ul><p><strong>（不确定度与误差是不同的量）</strong></p><h4 id="a.直接测量量不确定度的计算分析"><strong>A.直接测量量不确定度的计算分析：</strong></h4><figure><img src="物理实验Note.assets/image-20220225211225648.png" alt="image-20220225211225648" /><figcaption aria-hidden="true">image-20220225211225648</figcaption></figure><figure><img src="物理实验Note.assets/image-20220225211338754.png" alt="image-20220225211338754" /><figcaption aria-hidden="true">image-20220225211338754</figcaption></figure><p>例子：</p><figure><img src="物理实验Note.assets/image-20220225211427208.png" alt="image-20220225211427208" /><figcaption aria-hidden="true">image-20220225211427208</figcaption></figure><figure><img src="物理实验Note.assets/image-20220225211556251.png" alt="image-20220225211556251" /><figcaption aria-hidden="true">image-20220225211556251</figcaption></figure><p><strong>注意上图的不确定度的估计原则</strong></p><p>物理量的测量可分为 <strong>单次测量</strong> 和 <strong>多次测量</strong>：</p><h4 id="一单次测量">一、单次测量</h4><figure><img src="物理实验Note.assets/image-20220225211824739.png" alt="image-20220225211824739" /><figcaption aria-hidden="true">image-20220225211824739</figcaption></figure><p>不确定度只有B类，A类为0（只测量了一次）记得要修约和对齐</p><p>例子：</p><figure><img src="物理实验Note.assets/image-20220225212127865.png" alt="image-20220225212127865" /><figcaption aria-hidden="true">image-20220225212127865</figcaption></figure><h4 id="二多次重复测量">二、多次重复测量</h4><figure><img src="物理实验Note.assets/image-20220225212325914.png" alt="image-20220225212325914" /><figcaption aria-hidden="true">image-20220225212325914</figcaption></figure><p>(A和B类都有)</p><p>例子：</p><figure><img src="物理实验Note.assets/image-20220223110129867.png" alt="image-20220223110129867" /><figcaption aria-hidden="true">image-20220223110129867</figcaption></figure><figure><img src="物理实验Note.assets/image-20220225212629988.png" alt="image-20220225212629988" /><figcaption aria-hidden="true">image-20220225212629988</figcaption></figure><h4 id="三相对不确定度和百分差">三、相对不确定度和百分差</h4><figure><img src="物理实验Note.assets/image-20220223110449489.png" alt="image-20220223110449489" /><figcaption aria-hidden="true">image-20220223110449489</figcaption></figure><p><strong>所有的不确定修约规则都是相同的</strong></p><p>例子：</p><figure><img src="物理实验Note.assets/image-20220225213424038.png" alt="image-20220225213424038" /><figcaption aria-hidden="true">image-20220225213424038</figcaption></figure><h4 id="b.间接测量量不确定度的结果表示与计算分析">B.<strong>间接测量量不确定度的结果表示与计算分析:</strong></h4><figure><img src="物理实验Note.assets/image-20220225213713878.png" alt="image-20220225213713878" /><figcaption aria-hidden="true">image-20220225213713878</figcaption></figure><figure><img src="物理实验Note.assets/image-20220225213908662.png" alt="image-20220225213908662" /><figcaption aria-hidden="true">image-20220225213908662</figcaption></figure><p>(注意第二条公式)</p><figure><img src="物理实验Note.assets/image-20220225213951499.png" alt="image-20220225213951499" /><figcaption aria-hidden="true">image-20220225213951499</figcaption></figure><h2 id="五数据的基本处理方法">五、数据的基本处理方法</h2><p><strong>数据处理方法</strong></p><ul><li>列表法</li><li>作图法 （图要简明美观）（图解法，取图画上显示较远的两点）</li><li>逐差法(自变量之间等间距变化的数据）（最小二乘法）</li></ul><figure><img src="物理实验Note.assets/image-20220223113821757.png" alt="image-20220223113821757" /><figcaption aria-hidden="true">image-20220223113821757</figcaption></figure>]]></content>
    
    
    
    <tags>
      
      <tag>learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/04/13/hello-world/"/>
    <url>/2022/04/13/hello-world/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
